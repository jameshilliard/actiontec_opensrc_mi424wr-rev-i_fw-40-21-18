# OBSOLETE //  -*- C -*-
# OBSOLETE //  Mitsubishi Electric Corp. D30V Simulator.
# OBSOLETE //  Copyright (C) 1997, Free Software Foundation, Inc.
# OBSOLETE //  Contributed by Cygnus Solutions Inc.
# OBSOLETE //
# OBSOLETE //  This file is part of GDB, the GNU debugger.
# OBSOLETE //
# OBSOLETE //  This program is free software; you can redistribute it and/or modify
# OBSOLETE //  it under the terms of the GNU General Public License as published by
# OBSOLETE //  the Free Software Foundation; either version 2 of the License, or
# OBSOLETE //  (at your option) any later version.
# OBSOLETE //
# OBSOLETE //  This program is distributed in the hope that it will be useful,
# OBSOLETE //  but WITHOUT ANY WARRANTY; without even the implied warranty of
# OBSOLETE //  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# OBSOLETE //  GNU General Public License for more details.
# OBSOLETE //
# OBSOLETE //  You should have received a copy of the GNU General Public License
# OBSOLETE //  along with this program; if not, write to the Free Software
# OBSOLETE //  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
# OBSOLETE //
# OBSOLETE 
# OBSOLETE 
# OBSOLETE define( _BRA,  `1.*,CCC,000')
# OBSOLETE define( _LOGIC, `1.*,CCC,001')
# OBSOLETE define( _IMEM, `1.*,CCC,010')
# OBSOLETE define( _IALU1, `1.*,CCC,100')
# OBSOLETE define(_IALU2, `1.*,CCC,101')
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE define(_IMM6, `6.IMM_6S')
# OBSOLETE define(_IMM12, `12.IMM_12S')
# OBSOLETE define(_IMM18, `18.IMM_18S')
# OBSOLETE define(_IMM32, `6.IMM_6L,*,000,8.IMM_8L,00,18.IMM_18L')
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // The following is called when ever an illegal instruction is
# OBSOLETE // encountered
# OBSOLETE ::internal::illegal
# OBSOLETE 	sim_io_eprintf (sd, "illegal instruction at 0x%lx\n", (long) cia);
# OBSOLETE 	sim_engine_halt (SD, CPU, NULL, cia, sim_signalled, SIM_SIGILL);
# OBSOLETE 
# OBSOLETE // The following is called when ever an instruction in the wrong
# OBSOLETE // slot is encountered.
# OBSOLETE ::internal::wrong_slot
# OBSOLETE 	sim_io_eprintf (sd, "wrong slot at 0x%lx\n", (long) cia);
# OBSOLETE 	sim_engine_halt (SD, CPU, NULL, cia, sim_signalled, SIM_SIGILL);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // Something illegal that can be used to contact the simulator emul
# OBSOLETE // library.
# OBSOLETE define(_EMUL, `1.*,CCC,111')
# OBSOLETE 
# OBSOLETE void::function::do_emul:int imm
# OBSOLETE 	/* temp hack - later replace with real interface */
# OBSOLETE 	enum {
# OBSOLETE 	  param1 = 2, param2, param3, param4
# OBSOLETE 	};
# OBSOLETE 	switch (imm) {
# OBSOLETE 	case 0:
# OBSOLETE 	  {
# OBSOLETE 	    sim_engine_abort (SD, CPU, cia, "UNIX call emulation unsupported");
# OBSOLETE 	    break;
# OBSOLETE 	  }
# OBSOLETE 	case 1:
# OBSOLETE 	  /* Trap 1 - prints a string */
# OBSOLETE 	  {
# OBSOLETE 	    address_word str = GPR[param1];
# OBSOLETE 	    char chr;
# OBSOLETE 	    while (1) {
# OBSOLETE 	      chr = MEM (unsigned, str, 1);
# OBSOLETE 	    if (chr == '\0') break;
# OBSOLETE 	      sim_io_write_stdout (sd, &chr, sizeof chr);
# OBSOLETE 	      str++;
# OBSOLETE 	    }
# OBSOLETE 	    break;
# OBSOLETE 	  }
# OBSOLETE 	case 3:
# OBSOLETE 	  /* Trap 3 - writes a character */
# OBSOLETE 	  {
# OBSOLETE 	    char chr = GPR[param1];
# OBSOLETE 	    sim_io_write_stdout (sd, &chr, sizeof chr);
# OBSOLETE 	    break;
# OBSOLETE 	  }
# OBSOLETE 	case 4:
# OBSOLETE 	  /* Trap 4 exits with status in [param1] */
# OBSOLETE 	  {
# OBSOLETE 	    sim_engine_halt (SD, CPU, NULL, cia, sim_exited, GPR[param1]);
# OBSOLETE 	    break;
# OBSOLETE 	  }
# OBSOLETE 	case 5:
# OBSOLETE 	  /* Trap 5 breakpoints.  If the breakpoint system knows about this, it
# OBSOLETE 	     won't return.  Otherwise, we fall through to treat this as an
# OBSOLETE 	     unknown instruction.  */
# OBSOLETE 	  {
# OBSOLETE 	    sim_handle_breakpoint (SD, CPU, cia);
# OBSOLETE 	  /* Fall through to default case.*/
# OBSOLETE 	  }
# OBSOLETE 	default:
# OBSOLETE 	  sim_engine_abort (SD, CPU, cia, "Unknown monitor call %d", imm);
# OBSOLETE 	}
# OBSOLETE 
# OBSOLETE _EMUL,00000,00,6.*,6.*,IMM_6S:EMUL:short,emul:iu,mu:EMUL
# OBSOLETE "syscall <imm>"
# OBSOLETE 	do_emul (_SD, imm);
# OBSOLETE _BRA,00000,00,6.**,6.**,_IMM32:BRA:long:iu,mu:EMUL long
# OBSOLETE "syscall <imm>"
# OBSOLETE 	do_emul (_SD, imm);
# OBSOLETE 
# OBSOLETE // ABS
# OBSOLETE 
# OBSOLETE _IALU1,01000,00,6.RA,6.RB,6.**:IALU1:short:iu,mu:ABS
# OBSOLETE "abs r<RA>, r<RB>"
# OBSOLETE 	WRITE32_QUEUE (Ra, abs(Rb));
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // ADD
# OBSOLETE 
# OBSOLETE void::function::do_add:unsigned32 *ra, unsigned32 rb, unsigned32 imm
# OBSOLETE 	ALU_BEGIN(rb);
# OBSOLETE 	ALU_ADDC(imm);
# OBSOLETE 	ALU_END(ra);
# OBSOLETE 
# OBSOLETE _IALU1,00000,00,6.RA,6.RB,6.RC:IALU1:short:iu,mu:ADD
# OBSOLETE "add r<RA>, r<RB>, r<RC>"
# OBSOLETE 	do_add (_SD, Ra, Rb, Rc);
# OBSOLETE _IALU1,00000,10,6.RA,6.RB,_IMM6:IALU1:short:iu,mu:ADD imm
# OBSOLETE "add r<RA>, r<RB>, <imm>"
# OBSOLETE 	do_add (_SD, Ra, Rb, imm);
# OBSOLETE _IALU1,00000,10,6.RA,6.RB,_IMM32:IALU1:long:iu,mu:ADD imm long
# OBSOLETE "add r<RA>, r<RB>, <imm>"
# OBSOLETE 	do_add (_SD, Ra, Rb, imm);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // ADD2H
# OBSOLETE 
# OBSOLETE void::function::do_add2h:signed32 *ra, signed32 rb, signed32 imm
# OBSOLETE 	unsigned16 ah2 = VH2_4(rb) + VH2_4(imm);
# OBSOLETE 	unsigned16 al2 = VL2_4(rb) + VL2_4(imm);
# OBSOLETE 	WRITE32_QUEUE (ra, (ah2 << 16) | al2);
# OBSOLETE 
# OBSOLETE _IALU1,00001,00,6.RA,6.RB,6.RC:IALU1:short:iu,mu:ADD2H
# OBSOLETE "add2h r<RA>, r<RB>, r<RC>"
# OBSOLETE 	do_add2h (_SD, Ra, Rb, Rc);
# OBSOLETE _IALU1,00001,10,6.RA,6.RB,_IMM6:IALU1:short:iu,mu:ADD2H imm
# OBSOLETE "add2h r<RA>, r<RB>, <imm>"
# OBSOLETE 	do_add2h (_SD, Ra, Rb, immHL);
# OBSOLETE _IALU1,00001,10,6.RA,6.RB,_IMM32:IALU1:long:iu,mu:ADD2H imm long
# OBSOLETE "add2h r<RA>, r<RB>, <imm>"
# OBSOLETE 	do_add2h (_SD, Ra, Rb, imm);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // ADDC
# OBSOLETE 
# OBSOLETE void::function::do_addc:unsigned32 *ra, unsigned32 rb, unsigned32 imm
# OBSOLETE 	ALU_BEGIN(rb);
# OBSOLETE 	ALU_ADDC_C(imm, ALU_CARRY);
# OBSOLETE 	ALU_END(ra);
# OBSOLETE 
# OBSOLETE _IALU1,00100,00,6.RA,6.RB,6.RC:IALU1:short:iu,mu:ADDC
# OBSOLETE "addc r<RA>, r<RB>, r<RC>"
# OBSOLETE 	do_addc (_SD, Ra, Rb, Rc);
# OBSOLETE _IALU1,00100,10,6.RA,6.RB,_IMM6:IALU1:short:iu,mu:ADDC imm
# OBSOLETE "addc r<RA>, r<RB>, <imm>"
# OBSOLETE 	do_addc (_SD, Ra, Rb, imm);
# OBSOLETE _IALU1,00100,10,6.RA,6.RB,_IMM32:IALU1:long:iu,mu:ADDC imm long
# OBSOLETE "addc r<RA>, r<RB>, <imm>"
# OBSOLETE 	do_addc (_SD, Ra, Rb, imm);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // ADDHppp
# OBSOLETE 
# OBSOLETE void::function::do_addh_ppp:int ppp, unsigned32 *ra, unsigned32 rb, unsigned32 src
# OBSOLETE 	switch (ppp) {
# OBSOLETE 	case 0x0: /* LLL */
# OBSOLETE 	  {
# OBSOLETE 	  ALU16_BEGIN(VL2_4(rb));
# OBSOLETE 	  ALU16_ADDC(VL2_4(src));
# OBSOLETE 	  ALU16_END(ra, 0);
# OBSOLETE 	  }
# OBSOLETE 	  break;
# OBSOLETE 	case 0x1: /* LLH */
# OBSOLETE 	  {
# OBSOLETE 	  ALU16_BEGIN(VL2_4(rb));
# OBSOLETE 	  ALU16_ADDC(VH2_4(src));
# OBSOLETE 	  ALU16_END(ra, 0);
# OBSOLETE 	  }
# OBSOLETE 	  break;
# OBSOLETE 	case 0x2: /* LHL */
# OBSOLETE 	  {
# OBSOLETE 	  ALU16_BEGIN(VH2_4(rb));
# OBSOLETE 	  ALU16_ADDC(VL2_4(src));
# OBSOLETE 	  ALU16_END(ra, 0);
# OBSOLETE 	  }
# OBSOLETE 	  break;
# OBSOLETE 	case 0x3: /* LHH */
# OBSOLETE 	  {
# OBSOLETE 	  ALU16_BEGIN(VH2_4(rb));
# OBSOLETE 	  ALU16_ADDC(VH2_4(src));
# OBSOLETE 	  ALU16_END(ra, 0);
# OBSOLETE 	  }
# OBSOLETE 	  break;
# OBSOLETE 	case 0x4: /* HLL */
# OBSOLETE 	  {
# OBSOLETE 	  ALU16_BEGIN(VL2_4(rb));
# OBSOLETE 	  ALU16_ADDC(VL2_4(src));
# OBSOLETE 	  ALU16_END(ra, 1);
# OBSOLETE 	  }
# OBSOLETE 	  break;
# OBSOLETE 	case 0x5: /* HLH */
# OBSOLETE 	  {
# OBSOLETE 	  ALU16_BEGIN(VL2_4(rb));
# OBSOLETE 	  ALU16_ADDC(VH2_4(src));
# OBSOLETE 	  ALU16_END(ra, 1);
# OBSOLETE 	  }
# OBSOLETE 	  break;
# OBSOLETE 	case 0x6: /* HHL */
# OBSOLETE 	  {
# OBSOLETE 	  ALU16_BEGIN(VH2_4(rb));
# OBSOLETE 	  ALU16_ADDC(VL2_4(src));
# OBSOLETE 	  ALU16_END(ra, 1);
# OBSOLETE 	  }
# OBSOLETE 	  break;
# OBSOLETE 	case 0x7: /* HHH */
# OBSOLETE 	  {	
# OBSOLETE 	  ALU16_BEGIN(VH2_4(rb));
# OBSOLETE 	  ALU16_ADDC(VH2_4(src));
# OBSOLETE 	  ALU16_END(ra, 1);
# OBSOLETE 	  }
# OBSOLETE 	  break;
# OBSOLETE 	default:
# OBSOLETE 	  sim_engine_abort (SD, CPU, cia, "do_addh_ppp - internal error - bad switch");
# OBSOLETE 	}
# OBSOLETE ::%s::ppp:int ppp
# OBSOLETE 	switch (ppp)
# OBSOLETE 	  {
# OBSOLETE 	  case 0x0: return "lll";
# OBSOLETE 	  case 0x1: return "llh";
# OBSOLETE 	  case 0x2: return "lhl";
# OBSOLETE 	  case 0x3: return "lhh";
# OBSOLETE 	  case 0x4: return "hll";
# OBSOLETE 	  case 0x5: return "hlh";
# OBSOLETE 	  case 0x6: return "hhl";
# OBSOLETE 	  case 0x7: return "hhh";
# OBSOLETE 	  default: return "?";
# OBSOLETE 	  }
# OBSOLETE 
# OBSOLETE _IALU1,10,ppp,00,6.RA,6.RB,6.RC:IALU1:short:iu,mu:ADDHppp
# OBSOLETE "addh%s<ppp> r<RA>, r<RB>, r<RC>"
# OBSOLETE 	do_addh_ppp(_SD, ppp, Ra, Rb, Rc);
# OBSOLETE _IALU1,10,ppp,10,6.RA,6.RB,_IMM6:IALU1:short:iu,mu:ADDHppp imm
# OBSOLETE "addh%s<ppp> r<RA>, r<RB>, <imm>"
# OBSOLETE 	do_addh_ppp(_SD, ppp, Ra, Rb, immHL);
# OBSOLETE _IALU1,10,ppp,10,6.RA,6.RB,_IMM32:IALU1:long:iu,mu:ADDHppp imm long
# OBSOLETE "addh%s<ppp> r<RA>, r<RB>, <imm>"
# OBSOLETE 	do_addh_ppp(_SD, ppp, Ra, Rb, imm);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // ADDS
# OBSOLETE 
# OBSOLETE void::function::do_adds:unsigned32 *ra, unsigned32 rb, unsigned32 imm
# OBSOLETE 	ALU_BEGIN(rb);
# OBSOLETE 	ALU_ADDC(EXTRACTED32(imm, 0, 0));
# OBSOLETE 	ALU_END(ra);
# OBSOLETE 
# OBSOLETE _IALU1,00110,00,6.RA,6.RB,6.RC:IALU1:short:iu,mu:ADDS
# OBSOLETE "adds r<RA>, r<RB>, r<RC>"
# OBSOLETE 	do_adds (_SD, Ra, Rb, Rc);
# OBSOLETE _IALU1,00110,10,6.RA,6.RB,_IMM6:IALU1:short:iu,mu:ADDS imm
# OBSOLETE "adds r<RA>, r<RB>, <imm>"
# OBSOLETE 	do_adds (_SD, Ra, Rb, imm);
# OBSOLETE _IALU1,00110,10,6.RA,6.RB,_IMM32:IALU1:long:iu,mu:ADDS imm long
# OBSOLETE "adds r<RA>, r<RB>, <imm>"
# OBSOLETE 	do_adds (_SD, Ra, Rb, imm);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // ADDS2H
# OBSOLETE 
# OBSOLETE void::function::do_adds2h:unsigned32 *ra, unsigned32 rb, unsigned32 immHL
# OBSOLETE 	unsigned16 high = VH2_4(rb) + EXTRACTED32(immHL, 0, 0);
# OBSOLETE 	unsigned16 low = VL2_4(rb) + EXTRACTED32(immHL, 16, 16);
# OBSOLETE 	WRITE32_QUEUE (ra, (high << 16) | low);
# OBSOLETE 
# OBSOLETE _IALU1,00111,00,6.RA,6.RB,6.RC:IALU1:short:iu,mu:ADDS2H
# OBSOLETE "adds2h r<RA>, r<RB>, r<RC>"
# OBSOLETE 	do_adds2h (_SD, Ra, Rb, Rc);
# OBSOLETE _IALU1,00111,10,6.RA,6.RB,_IMM6:IALU1:short:iu,mu:ADDS2H imm
# OBSOLETE "adds2h r<RA>, r<RB>, <imm>"
# OBSOLETE 	do_adds2h (_SD, Ra, Rb, immHL);
# OBSOLETE _IALU1,00111,10,6.RA,6.RB,_IMM32:IALU1:long:iu,mu:ADDS2H imm long
# OBSOLETE "adds2h r<RA>, r<RB>, <imm>"
# OBSOLETE 	do_adds2h (_SD, Ra, Rb, imm);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // AND
# OBSOLETE 
# OBSOLETE _LOGIC,11000,00,6.RA,6.RB,6.RC:LOGIC:short:iu,mu:AND
# OBSOLETE "and r<RA>, r<RB>, r<RC>"
# OBSOLETE 	WRITE32_QUEUE (Ra, Rb & Rc);
# OBSOLETE _LOGIC,11000,10,6.RA,6.RB,_IMM6:LOGIC:short:iu,mu:AND imm
# OBSOLETE "and r<RA>, r<RB>, <imm>"
# OBSOLETE 	WRITE32_QUEUE (Ra, Rb & imm);
# OBSOLETE _LOGIC,11000,10,6.RA,6.RB,_IMM32:LOGIC:long:iu,mu:AND imm long
# OBSOLETE "and r<RA>, r<RB>, <imm>"
# OBSOLETE 	WRITE32_QUEUE (Ra, Rb & imm);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // ANDFG
# OBSOLETE 
# OBSOLETE _LOGIC,01000,00,***,3.FA,***,3.FB,***,3.FC:LOGIC:short:iu,mu:Logical AND Flags
# OBSOLETE "andfg f<FA>, f<FB>, f<FC>"
# OBSOLETE 	PSW_FLAG_SET_QUEUE(FA, PSW_FLAG_VAL(FB) & PSW_FLAG_VAL(FC));
# OBSOLETE _LOGIC,01000,10,***,3.FA,***,3.FB,_IMM6:LOGIC:short:iu,mu:Logical AND Flags imm
# OBSOLETE "andfg f<FA>, f<FB>, <imm_6>"
# OBSOLETE 	PSW_FLAG_SET_QUEUE(FA, PSW_FLAG_VAL(FB) & (imm_6 & 1));
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // AVG
# OBSOLETE 
# OBSOLETE void::function::do_avg:unsigned32 *ra, unsigned32 rb, unsigned32 imm
# OBSOLETE 	WRITE32_QUEUE (ra, ((signed64)(signed32)rb + (signed64)(signed32)imm + 1) >> 1);
# OBSOLETE 
# OBSOLETE _IALU1,01010,00,6.RA,6.RB,6.RC:IALU1:short:iu,mu:AVG
# OBSOLETE "avg r<RA>, r<RB>, r<RC>"
# OBSOLETE 	do_avg (_SD, Ra, Rb, Rc);
# OBSOLETE _IALU1,01010,10,6.RA,6.RB,_IMM6:IALU1:short:iu,mu:AVG imm
# OBSOLETE "avg r<RA>, r<RB>, <imm>"
# OBSOLETE 	do_avg (_SD, Ra, Rb, imm);
# OBSOLETE _IALU1,01010,10,6.RA,6.RB,_IMM32:IALU1:long:iu,mu:AVG imm long
# OBSOLETE "avg r<RA>, r<RB>, <imm>"
# OBSOLETE 	do_avg (_SD, Ra, Rb, imm);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // AVG2H
# OBSOLETE 
# OBSOLETE void::function::do_avg2h:unsigned32 *ra, unsigned32 rb, unsigned32 imm
# OBSOLETE 	unsigned16 high = ((signed32)(signed16)VH2_4(rb) + (signed32)(signed16)VH2_4(imm) + 1) >> 1;
# OBSOLETE 	unsigned16 low  = ((signed32)(signed16)VL2_4(rb) + (signed32)(signed16)VL2_4(imm) + 1) >> 1;
# OBSOLETE 	WRITE32_QUEUE (ra, (high << 16) | low);
# OBSOLETE 
# OBSOLETE _IALU1,01011,00,6.RA,6.RB,6.RC:IALU1:short:iu,mu:AVG2H
# OBSOLETE "avg2h r<RA>, r<RB>, r<RC>"
# OBSOLETE 	do_avg2h (_SD, Ra, Rb, Rc);
# OBSOLETE _IALU1,01011,10,6.RA,6.RB,_IMM6:IALU1:short:iu,mu:AVG2H imm
# OBSOLETE "avg2h r<RA>, r<RB>, <imm>"
# OBSOLETE 	do_avg2h (_SD, Ra, Rb, immHL);
# OBSOLETE _IALU1,01011,10,6.RA,6.RB,_IMM32:IALU1:long:iu,mu:AVG2H imm long
# OBSOLETE "avg2h r<RA>, r<RB>, <imm>"
# OBSOLETE 	do_avg2h (_SD, Ra, Rb, imm);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // BCLR
# OBSOLETE 
# OBSOLETE _LOGIC,00011,00,6.RA,6.RB,6.RC:LOGIC:short:iu,mu:BCLR
# OBSOLETE "bclr r<RA>, r<RB>, r<RC>"
# OBSOLETE 	WRITE32_QUEUE(Ra, Rb & ~BIT32((Rc) % 32));
# OBSOLETE _LOGIC,00011,10,6.RA,6.RB,_IMM6:LOGIC:short:iu,mu:BCLR imm
# OBSOLETE "bclr r<RA>, r<RB>, <imm>"
# OBSOLETE 	WRITE32_QUEUE(Ra, Rb & ~BIT32((imm) % 32));
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // BNOT
# OBSOLETE 
# OBSOLETE _LOGIC,00001,00,6.RA,6.RB,6.RC:LOGIC:short:iu,mu:BNOT
# OBSOLETE "bnot r<RA>, r<RB>, r<RC>"
# OBSOLETE 	WRITE32_QUEUE (Ra, Rb ^ BIT32((Rc) % 32));
# OBSOLETE _LOGIC,00001,10,6.RA,6.RB,_IMM6:LOGIC:short:iu,mu:BNOT imm
# OBSOLETE "bnot r<RA>, r<RB>, <imm>"
# OBSOLETE 	WRITE32_QUEUE (Ra, Rb ^ BIT32((imm) % 32));
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // BRA
# OBSOLETE 
# OBSOLETE _BRA,00000,00,6.**,6.**,6.RC:BRA:short:mu:BRA
# OBSOLETE "bra r<RC>"
# OBSOLETE 	nia = cia + pcdisp;
# OBSOLETE _BRA,00000,10,_IMM18:BRA:short:mu:BRA imm
# OBSOLETE "bra <pcdisp>"
# OBSOLETE 	nia = cia + pcdisp;
# OBSOLETE _BRA,00000,10,6.**,6.**,_IMM32:BRA:long:mu:BRA imm long
# OBSOLETE "bra <pcdisp>"
# OBSOLETE 	nia = cia + pcdisp;
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // BRATNZ
# OBSOLETE 
# OBSOLETE _BRA,00100,01,6.RA,6.**,6.RC:BRA:short:mu:BRATNZ
# OBSOLETE "bratnz r<RC>"
# OBSOLETE 	if (*Ra != 0)
# OBSOLETE 	  nia = cia + pcdisp;
# OBSOLETE _BRA,00100,11,6.RA,_IMM12:BRA:short:mu:BRATNZ imm
# OBSOLETE "bratnz <pcdisp>"
# OBSOLETE 	if (*Ra != 0)
# OBSOLETE 	  nia = cia + pcdisp;
# OBSOLETE _BRA,00100,11,6.RA,6.**,_IMM32:BRA:long:mu:BRATNZ imm long
# OBSOLETE "bratnz <pcdisp>"
# OBSOLETE 	if (*Ra != 0)
# OBSOLETE 	  nia = cia + pcdisp;
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // BRATZR
# OBSOLETE 
# OBSOLETE _BRA,00100,00,6.RA,6.**,6.RC:BRA:short:mu:BRATZR
# OBSOLETE "bratzr r<RC>"
# OBSOLETE 	if (val_Ra == 0)
# OBSOLETE 	  nia = cia + pcdisp;
# OBSOLETE _BRA,00100,10,6.RA,_IMM12:BRA:short:mu:BRATZR imm
# OBSOLETE "bratzr <pcdisp>"
# OBSOLETE 	if (val_Ra == 0)
# OBSOLETE 	  nia = cia + pcdisp;
# OBSOLETE _BRA,00100,10,6.RA,6.**,_IMM32:BRA:long:mu:BRATZR imm long
# OBSOLETE "bratzr <pcdisp>"
# OBSOLETE 	if (val_Ra == 0)
# OBSOLETE 	  nia = cia + pcdisp;
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // BSET
# OBSOLETE 
# OBSOLETE _LOGIC,00010,00,6.RA,6.RB,6.RC:LOGIC:short:iu,mu:BSET
# OBSOLETE "bset r<RA>, r<RB>, r<RC>"
# OBSOLETE 	WRITE32_QUEUE (Ra, Rb | BIT32((Rc) % 32));
# OBSOLETE _LOGIC,00010,10,6.RA,6.RB,_IMM6:LOGIC:short:iu,mu:BSET imm
# OBSOLETE "bset r<RA>, r<RB>, <imm>"
# OBSOLETE 	WRITE32_QUEUE (Ra, Rb | BIT32((imm) % 32));
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // BSR
# OBSOLETE 
# OBSOLETE _BRA,00010,00,6.**,6.**,6.RC:BRA:short:mu:BSR
# OBSOLETE "bsr r<RC>"
# OBSOLETE 	if (cia == RPT_E && PSW_VAL (PSW_RP))
# OBSOLETE 	  WRITE32_QUEUE (&GPR[62], RPT_S);
# OBSOLETE 	else
# OBSOLETE 	  WRITE32_QUEUE (&GPR[62], cia + 8);
# OBSOLETE 	nia = cia + pcdisp;
# OBSOLETE 	if (TRACE_CALL_P)
# OBSOLETE 	  TRACE_ACTION |= TRACE_ACTION_CALL;
# OBSOLETE _BRA,00010,10,_IMM18:BRA:short:mu:BSR imm
# OBSOLETE "bsr <pcdisp>"
# OBSOLETE 	if (cia == RPT_E && PSW_VAL (PSW_RP))
# OBSOLETE 	  WRITE32_QUEUE (&GPR[62], RPT_S);
# OBSOLETE 	else
# OBSOLETE 	  WRITE32_QUEUE (&GPR[62], cia + 8);
# OBSOLETE 	nia = cia + pcdisp;
# OBSOLETE 	if (TRACE_CALL_P)
# OBSOLETE 	  TRACE_ACTION |= TRACE_ACTION_CALL;
# OBSOLETE _BRA,00010,10,6.**,6.**,_IMM32:BRA:long:mu:BSR imm long
# OBSOLETE "bsr <pcdisp>"
# OBSOLETE 	if (cia == RPT_E && PSW_VAL (PSW_RP))
# OBSOLETE 	  WRITE32_QUEUE (&GPR[62], RPT_S);
# OBSOLETE 	else
# OBSOLETE 	  WRITE32_QUEUE (&GPR[62], cia + 8);
# OBSOLETE 	nia = cia + pcdisp;
# OBSOLETE 	if (TRACE_CALL_P)
# OBSOLETE 	  TRACE_ACTION |= TRACE_ACTION_CALL;
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // BSRTNZ
# OBSOLETE 
# OBSOLETE _BRA,00110,01,6.RA,6.**,6.RC:BRA:short:mu:BSRTNZ
# OBSOLETE "bsrtnz r<RC>"
# OBSOLETE 	if (val_Ra != 0) {
# OBSOLETE 	  if (cia == RPT_E && PSW_VAL (PSW_RP))
# OBSOLETE 	    WRITE32_QUEUE (&GPR[62], RPT_S);
# OBSOLETE 	  else
# OBSOLETE 	    WRITE32_QUEUE (&GPR[62], cia + 8);
# OBSOLETE 	  nia = cia + pcdisp;
# OBSOLETE 	  if (TRACE_CALL_P)
# OBSOLETE 	    TRACE_ACTION |= TRACE_ACTION_CALL;
# OBSOLETE 	}
# OBSOLETE 
# OBSOLETE _BRA,00110,11,6.RA,_IMM12:BRA:short:mu:BSRTNZ imm
# OBSOLETE "bsrtnz <pcdisp>"
# OBSOLETE 	if (val_Ra != 0) {
# OBSOLETE 	  if (cia == RPT_E && PSW_VAL (PSW_RP))
# OBSOLETE 	    WRITE32_QUEUE (&GPR[62], RPT_S);
# OBSOLETE 	  else
# OBSOLETE 	    WRITE32_QUEUE (&GPR[62], cia + 8);
# OBSOLETE 	  nia = cia + pcdisp;
# OBSOLETE 	  if (TRACE_CALL_P)
# OBSOLETE 	    TRACE_ACTION |= TRACE_ACTION_CALL;
# OBSOLETE 	}
# OBSOLETE 
# OBSOLETE _BRA,00110,11,6.RA,6.**,_IMM32:BRA:long:mu:BSRTNZ imm long
# OBSOLETE "bsrtnz <pcdisp>"
# OBSOLETE 	if (val_Ra != 0) {
# OBSOLETE 	  if (cia == RPT_E && PSW_VAL (PSW_RP))
# OBSOLETE 	    WRITE32_QUEUE (&GPR[62], RPT_S);
# OBSOLETE 	  else
# OBSOLETE 	    WRITE32_QUEUE (&GPR[62], cia + 8);
# OBSOLETE 	  nia = cia + pcdisp;
# OBSOLETE 	  if (TRACE_CALL_P)
# OBSOLETE 	    TRACE_ACTION |= TRACE_ACTION_CALL;
# OBSOLETE 	}
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // BSRTZR
# OBSOLETE 
# OBSOLETE _BRA,00110,00,6.RA,6.**,6.RC:BRA:short:mu:BSRTZR
# OBSOLETE "bsrtzr r<RC>"
# OBSOLETE 	if (val_Ra == 0) {
# OBSOLETE 	  if (cia == RPT_E && PSW_VAL (PSW_RP))
# OBSOLETE 	    WRITE32_QUEUE (&GPR[62], RPT_S);
# OBSOLETE 	  else
# OBSOLETE 	    WRITE32_QUEUE (&GPR[62], cia + 8);
# OBSOLETE 	  nia = cia + pcdisp;
# OBSOLETE 	  if (TRACE_CALL_P)
# OBSOLETE 	    TRACE_ACTION |= TRACE_ACTION_CALL;
# OBSOLETE 	}
# OBSOLETE 
# OBSOLETE _BRA,00110,10,6.RA,_IMM12:BRA:short:mu:BSRTZR imm
# OBSOLETE "bsrtzr <pcdisp>"
# OBSOLETE 	if (val_Ra == 0) {
# OBSOLETE 	  if (cia == RPT_E && PSW_VAL (PSW_RP))
# OBSOLETE 	    WRITE32_QUEUE (&GPR[62], RPT_S);
# OBSOLETE 	  else
# OBSOLETE 	    WRITE32_QUEUE (&GPR[62], cia + 8);
# OBSOLETE 	  nia = cia + pcdisp;
# OBSOLETE 	  if (TRACE_CALL_P)
# OBSOLETE 	    TRACE_ACTION |= TRACE_ACTION_CALL;
# OBSOLETE 	}
# OBSOLETE 
# OBSOLETE _BRA,00110,10,6.RA,6.**,_IMM32:BRA:long:mu:BSRTZR imm long
# OBSOLETE "bsrtzr <pcdisp>"
# OBSOLETE 	if (val_Ra == 0) {
# OBSOLETE 	  if (cia == RPT_E && PSW_VAL (PSW_RP))
# OBSOLETE 	    WRITE32_QUEUE (&GPR[62], RPT_S);
# OBSOLETE 	  else
# OBSOLETE 	    WRITE32_QUEUE (&GPR[62], cia + 8);
# OBSOLETE 	  nia = cia + pcdisp;
# OBSOLETE 	  if (TRACE_CALL_P)
# OBSOLETE 	    TRACE_ACTION |= TRACE_ACTION_CALL;
# OBSOLETE 	}
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // BTST
# OBSOLETE 
# OBSOLETE _LOGIC,00000,00,***,3.FA,6.RB,6.RC:LOGIC:short:iu,mu:BTST
# OBSOLETE "btst f<FA>, r<RB>, r<RC>"
# OBSOLETE 	int bit = (Rc) % 32;
# OBSOLETE 	PSW_FLAG_SET_QUEUE(FA, MASKED32(Rb, bit, bit));
# OBSOLETE _LOGIC,00000,10,***,3.FA,6.RB,_IMM6:LOGIC:short:iu,mu:BTST imm
# OBSOLETE "btst f<FA>, r<RB>, <imm>"
# OBSOLETE 	int bit = imm % 32;
# OBSOLETE 	PSW_FLAG_SET_QUEUE(FA, MASKED32(Rb, bit, bit));
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // CMPcc
# OBSOLETE 
# OBSOLETE void::function::do_cmp_cc:int cc, int fa, signed32 rb, signed32 rc
# OBSOLETE 	int value = 0;
# OBSOLETE 	switch (cc) {
# OBSOLETE 	case 0: /* EQ */
# OBSOLETE 	  value = (rb == rc);
# OBSOLETE 	  break;
# OBSOLETE 	case 1: /* NE */
# OBSOLETE 	  value = (rb != rc);
# OBSOLETE 	  break;
# OBSOLETE 	case 2: /* GT */
# OBSOLETE 	  value = (rb > rc);
# OBSOLETE 	  break;
# OBSOLETE 	case 3: /* GE */
# OBSOLETE 	  value = (rb >= rc);
# OBSOLETE 	  break;
# OBSOLETE 	case 4: /* LT */
# OBSOLETE 	  value = (rb < rc);
# OBSOLETE 	  break;
# OBSOLETE 	case 5: /* LE */
# OBSOLETE 	  value = (rb <= rc);
# OBSOLETE 	  break;
# OBSOLETE 	case 6: /* PS */
# OBSOLETE 	  value = ((rb >= 0) && (rc >= 0));
# OBSOLETE 	  break;
# OBSOLETE 	case 7: /* NG */
# OBSOLETE 	  value = ((rb < 0) && (rc < 0));
# OBSOLETE 	  break;
# OBSOLETE 	default:
# OBSOLETE 	  sim_engine_abort (SD, CPU, cia, "do_cmp_cc - internal error - bad switch (%d)", cc);
# OBSOLETE 	}
# OBSOLETE 	PSW_FLAG_SET_QUEUE(fa, value);
# OBSOLETE 
# OBSOLETE ::%s::ccc:int ccc
# OBSOLETE 	switch (ccc)
# OBSOLETE 	  {
# OBSOLETE 	  case 0: return "eq";
# OBSOLETE 	  case 1: return "ne";
# OBSOLETE 	  case 2: return "gt";
# OBSOLETE 	  case 3: return "ge";
# OBSOLETE 	  case 4: return "lt";
# OBSOLETE 	  case 5: return "le";
# OBSOLETE 	  case 6: return "ps";
# OBSOLETE 	  case 7: return "ng";
# OBSOLETE 	  default: return "?";
# OBSOLETE 	  }
# OBSOLETE 
# OBSOLETE _LOGIC,01100,00,ccc,3.FA,6.RB,6.RC:LOGIC:short:iu,mu:CMPcc
# OBSOLETE "cmp%s<ccc> f<FA>, r<RB>, r<RC>"
# OBSOLETE 	do_cmp_cc(_SD, ccc, FA, Rb, Rc);
# OBSOLETE _LOGIC,01100,10,ccc,3.FA,6.RB,_IMM6:LOGIC:short:iu,mu:CMPcc imm
# OBSOLETE "cmp%s<ccc> f<FA>, r<RB>, <imm>"
# OBSOLETE 	do_cmp_cc(_SD, ccc, FA, Rb, imm);
# OBSOLETE _LOGIC,01100,10,ccc,3.FA,6.RB,_IMM32:LOGIC:long:iu,mu:CMPcc imm long
# OBSOLETE "cmp%s<ccc> f<FA>, r<RB>, <imm>"
# OBSOLETE 	do_cmp_cc(_SD, ccc, FA, Rb, imm);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // CMPUcc
# OBSOLETE 
# OBSOLETE void::function::do_cmpu_cc:int cc, int fa, unsigned32 rb, unsigned32 rc
# OBSOLETE 	int value = 0;
# OBSOLETE 	switch (cc) {
# OBSOLETE 	case 2: /* GT */
# OBSOLETE 	  value = (rb > rc);
# OBSOLETE 	  break;
# OBSOLETE 	case 3: /* GE */
# OBSOLETE 	  value = (rb >= rc);
# OBSOLETE 	  break;
# OBSOLETE 	case 4: /* LT */
# OBSOLETE 	  value = (rb < rc);
# OBSOLETE 	  break;
# OBSOLETE 	case 5: /* LE */
# OBSOLETE 	  value = (rb <= rc);
# OBSOLETE 	  break;
# OBSOLETE 	default:
# OBSOLETE 	  sim_engine_abort (SD, CPU, cia, "do_cmpu_cc - internal error - bad switch (%d)", cc);
# OBSOLETE 	}
# OBSOLETE 	PSW_FLAG_SET_QUEUE(fa, value);
# OBSOLETE 
# OBSOLETE _LOGIC,01101,00,ccc,3.FA,6.RB,6.RC:LOGIC:short:iu,mu:CMPUcc
# OBSOLETE "cmpu%s<ccc> f<FA>, r<RB>, r<RC>"
# OBSOLETE 	do_cmpu_cc(_SD, ccc, FA, Rb, Rc);
# OBSOLETE _LOGIC,01101,10,ccc,3.FA,6.RB,_IMM6:LOGIC:short:iu,mu:CMPUcc imm
# OBSOLETE "cmpu%s<ccc> f<FA>, r<RB>, <imm>"
# OBSOLETE 	do_cmpu_cc(_SD, ccc, FA, Rb, imm_6u);
# OBSOLETE _LOGIC,01101,10,ccc,3.FA,6.RB,_IMM32:LOGIC:long:iu,mu:CMPUcc imm long
# OBSOLETE "cmpu%s<ccc> f<FA>, r<RB>, <imm>"
# OBSOLETE 	do_cmpu_cc(_SD, ccc, FA, Rb, imm);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // DBRA
# OBSOLETE 
# OBSOLETE void::function::do_dbra:address_word pcdisp, unsigned32 ra
# OBSOLETE 	PSW_SET_QUEUE (PSW_RP, 1);
# OBSOLETE 	WRITE32_QUEUE (&RPT_C, 1);
# OBSOLETE 	WRITE32_QUEUE (&RPT_S, cia + pcdisp);
# OBSOLETE 	WRITE32_QUEUE (&RPT_E, cia + (ra & ~0x7));
# OBSOLETE 
# OBSOLETE _BRA,10000,00,6.RA,6.**,6.RC:BRA:short:mu:DBRA
# OBSOLETE "dbra r<RA>, r<RC>"
# OBSOLETE 	do_dbra(_SD, pcdisp, val_Ra);
# OBSOLETE _BRA,10000,10,6.RA,_IMM12:BRA:short:mu:DBRA imm
# OBSOLETE "dbra r<RA>, <pcdisp>"
# OBSOLETE 	do_dbra(_SD, pcdisp, val_Ra);
# OBSOLETE _BRA,10000,10,6.RA,6.**,_IMM32:BRA:long:mu:DBRA imm long
# OBSOLETE "dbra r<RA>, <pcdisp>"
# OBSOLETE 	do_dbra(_SD, pcdisp, val_Ra);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // DBRAI
# OBSOLETE 
# OBSOLETE void::function::do_dbrai:address_word pcdisp, unsigned32 imm
# OBSOLETE 	PSW_SET_QUEUE (PSW_RP, 1);
# OBSOLETE 	WRITE32_QUEUE (&RPT_C, 1);
# OBSOLETE 	WRITE32_QUEUE (&RPT_S, cia + pcdisp);
# OBSOLETE 	WRITE32_QUEUE (&RPT_E, cia + (imm << 3));
# OBSOLETE 
# OBSOLETE _BRA,10100,00,6.IMM_6,6.**,6.RC:BRA:short:mu:DBRAI
# OBSOLETE "dbrai <IMM_6>, r<RC>"
# OBSOLETE 	do_dbrai(_SD, pcdisp, IMM_6);
# OBSOLETE _BRA,10100,10,6.IMM_6,_IMM12:BRA:short:mu:DBRAI imm
# OBSOLETE "dbrai <IMM_6>, <pcdisp>"
# OBSOLETE 	do_dbrai(_SD, pcdisp, IMM_6);
# OBSOLETE _BRA,10100,10,6.IMM_6,6.**,_IMM32:BRA:long:mu:DBRAI imm long
# OBSOLETE "dbrai <IMM_6>, <pcdisp>"
# OBSOLETE 	do_dbrai(_SD, pcdisp, IMM_6);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // DBSR
# OBSOLETE 
# OBSOLETE void::function::do_dbsr:address_word pcdisp, unsigned32 ra
# OBSOLETE 	PSW_SET_QUEUE (PSW_RP, 1);
# OBSOLETE 	WRITE32_QUEUE (&RPT_C, 1);
# OBSOLETE 	WRITE32_QUEUE (&RPT_S, cia + pcdisp);
# OBSOLETE 	WRITE32_QUEUE (&RPT_E, cia + ra);
# OBSOLETE 	WRITE32_QUEUE (&GPR[62], cia + ra + 8);
# OBSOLETE 
# OBSOLETE _BRA,10010,00,6.RA,6.**,6.RC:BRA:short:mu:DBSR
# OBSOLETE "dbsr r<RA>, r<RC>"
# OBSOLETE 	do_dbsr(_SD, pcdisp, val_Ra);
# OBSOLETE _BRA,10010,10,6.RA,_IMM12:BRA:short:mu:DBSR imm
# OBSOLETE "dbsr r<RA>, <pcdisp>"
# OBSOLETE 	do_dbsr(_SD, pcdisp, val_Ra);
# OBSOLETE _BRA,10010,10,6.RA,6.**,_IMM32:BRA:long:mu:DBSR imm long
# OBSOLETE "dbsr r<RA>, <pcdisp>"
# OBSOLETE 	do_dbsr(_SD, pcdisp, val_Ra);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // DBSRI
# OBSOLETE 
# OBSOLETE void::function::do_dbsri:address_word pcdisp, unsigned32 imm
# OBSOLETE 	PSW_SET_QUEUE (PSW_RP, 1);
# OBSOLETE 	WRITE32_QUEUE (&RPT_C, 1);
# OBSOLETE 	WRITE32_QUEUE (&RPT_S, cia + pcdisp);
# OBSOLETE 	WRITE32_QUEUE (&RPT_E, cia + (imm << 3));
# OBSOLETE 	WRITE32_QUEUE (&GPR[62], cia + (imm << 3) + 8);
# OBSOLETE 
# OBSOLETE _BRA,10110,00,6.IMM_6,6.**,6.RC:BRA:short:mu:DBSRI
# OBSOLETE "dbsri <IMM_6>, r<RC>"
# OBSOLETE 	do_dbsri(_SD, pcdisp, IMM_6);
# OBSOLETE _BRA,10110,10,6.IMM_6,_IMM12:BRA:short:mu:DBSRI imm
# OBSOLETE "dbsri <IMM_6>, <pcdisp>"
# OBSOLETE 	do_dbsri(_SD, pcdisp, IMM_6);
# OBSOLETE _BRA,10110,10,6.IMM_6,6.**,_IMM32:BRA:long:mu:DBSRI imm long
# OBSOLETE "dbsri <IMM_6>, <pcdisp>"
# OBSOLETE 	do_dbsri(_SD, pcdisp, IMM_6);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // DBT
# OBSOLETE 
# OBSOLETE 
# OBSOLETE _BRA,01011,00,6.**,6.**,6.**:BRA:short:mu:DBT
# OBSOLETE "dbt"
# OBSOLETE 	if (cia == RPT_E && PSW_VAL (PSW_RP))
# OBSOLETE 	  {
# OBSOLETE 	    WRITE32_QUEUE (&DPC, RPT_S);
# OBSOLETE 	    if (RPT_C == 0)
# OBSOLETE 	      PSW_SET (PSW_RP, 0);
# OBSOLETE 	  }
# OBSOLETE 	else
# OBSOLETE 	  WRITE32_QUEUE (&DPC, cia + 8);
# OBSOLETE 	DID_TRAP = 2;
# OBSOLETE 	nia = 0xfffff120; /* debug_trap_address */
# OBSOLETE 
# OBSOLETE // DJMP
# OBSOLETE 
# OBSOLETE void::function::do_djmp:address_word pcdisp, unsigned32 ra
# OBSOLETE 	PSW_SET_QUEUE (PSW_RP, 1);
# OBSOLETE 	WRITE32_QUEUE (&RPT_C, 1);
# OBSOLETE 	WRITE32_QUEUE (&RPT_S, pcdisp);
# OBSOLETE 	WRITE32_QUEUE (&RPT_E, cia + (ra & ~0x7));
# OBSOLETE 
# OBSOLETE _BRA,10001,00,6.RA,6.**,6.RC:BRA:short:mu:DJMP
# OBSOLETE "djmp r<RA>, r<RC>"
# OBSOLETE 	do_djmp(_SD, pcdisp, val_Ra);
# OBSOLETE _BRA,10001,10,6.RA,_IMM12:BRA:short:mu:DJMP imm
# OBSOLETE "djmp r<RA>, <pcdisp>"
# OBSOLETE 	do_djmp(_SD, pcdisp, val_Ra);
# OBSOLETE _BRA,10001,10,6.RA,6.**,_IMM32:BRA:long:mu:DJMP imm long
# OBSOLETE "djmp r<RA>, <pcdisp>"
# OBSOLETE 	do_djmp(_SD, pcdisp, val_Ra);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // DJMPI
# OBSOLETE 
# OBSOLETE void::function::do_djmpi:address_word pcdisp, unsigned32 imm
# OBSOLETE 	PSW_SET_QUEUE (PSW_RP, 1);
# OBSOLETE 	WRITE32_QUEUE (&RPT_C, 1);
# OBSOLETE 	WRITE32_QUEUE (&RPT_S, pcdisp);
# OBSOLETE 	WRITE32_QUEUE (&RPT_E, cia + (imm << 3));
# OBSOLETE 
# OBSOLETE _BRA,10101,00,6.IMM_6,6.**,6.RC:BRA:short:mu:DJMPI
# OBSOLETE "djmpi <IMM_6>, r<RC>"
# OBSOLETE 	do_djmpi(_SD, pcdisp, IMM_6);
# OBSOLETE _BRA,10101,10,6.IMM_6,_IMM12:BRA:short:mu:DJMPI imm
# OBSOLETE "djmpi <IMM_6>, <pcdisp>"
# OBSOLETE 	do_djmpi(_SD, pcdisp, IMM_6);
# OBSOLETE _BRA,10101,10,6.IMM_6,6.**,_IMM32:BRA:long:mu:DJMPI imm long
# OBSOLETE "djmpi <IMM_6>, <pcdisp>"
# OBSOLETE 	do_djmpi(_SD, pcdisp, IMM_6);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // DJSR
# OBSOLETE 
# OBSOLETE void::function::do_djsr:address_word pcdisp, unsigned32 ra
# OBSOLETE 	PSW_SET_QUEUE (PSW_RP, 1);
# OBSOLETE 	WRITE32_QUEUE (&RPT_C, 1);
# OBSOLETE 	WRITE32_QUEUE (&RPT_S, pcdisp);
# OBSOLETE 	WRITE32_QUEUE (&RPT_E, cia + (ra & ~0x7));
# OBSOLETE 	WRITE32_QUEUE (&GPR[62], cia + (ra & ~0x7) + 8);
# OBSOLETE 
# OBSOLETE _BRA,10011,00,6.RA,6.**,6.RC:BRA:short:mu:DJSR
# OBSOLETE "djsr r<RA>, r<RC>"
# OBSOLETE 	do_djsr(_SD, pcdisp, val_Ra);
# OBSOLETE _BRA,10011,10,6.RA,_IMM12:BRA:short:mu:DJSR imm
# OBSOLETE "djsr r<RA>, <pcdisp>"
# OBSOLETE 	do_djsr(_SD, pcdisp, val_Ra);
# OBSOLETE _BRA,10011,10,6.RA,6.**,_IMM32:BRA:long:mu:DJSR imm long
# OBSOLETE "djsr r<RA>, <pcdisp>"
# OBSOLETE 	do_djsr(_SD, pcdisp, val_Ra);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // DJSRI
# OBSOLETE 
# OBSOLETE void::function::do_djsri:address_word pcdisp, unsigned32 imm
# OBSOLETE 	PSW_SET_QUEUE (PSW_RP, 1);
# OBSOLETE 	WRITE32_QUEUE (&RPT_C, 1);
# OBSOLETE 	WRITE32_QUEUE (&RPT_S, pcdisp);
# OBSOLETE 	WRITE32_QUEUE (&RPT_E, cia + (imm << 3));
# OBSOLETE 	WRITE32_QUEUE (&GPR[62], cia + (imm << 3) + 8);
# OBSOLETE 
# OBSOLETE _BRA,10111,00,6.IMM_6,6.**,6.RC:BRA:short:mu:DJSRI
# OBSOLETE "djsri <IMM_6>, r<RC>"
# OBSOLETE 	do_djsri(_SD, pcdisp, IMM_6);
# OBSOLETE _BRA,10111,10,6.IMM_6,_IMM12:BRA:short:mu:DJSRI imm
# OBSOLETE "djsri <IMM_6>, <pcdisp>"
# OBSOLETE 	do_djsri(_SD, pcdisp, IMM_6);
# OBSOLETE _BRA,10111,10,6.IMM_6,6.**,_IMM32:BRA:long:mu:DJSRI imm long
# OBSOLETE "djsri <IMM_6>, <pcdisp>"
# OBSOLETE 	do_djsri(_SD, pcdisp, IMM_6);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // JMP
# OBSOLETE 
# OBSOLETE _BRA,00001,00,6.**,6.**,6.RC:BRA:short:mu:JMP
# OBSOLETE "jmp r<RC>"
# OBSOLETE 	nia = pcaddr;
# OBSOLETE 	if (RC == 62 && TRACE_CALL_P)
# OBSOLETE 	  TRACE_ACTION |= TRACE_ACTION_RETURN;
# OBSOLETE _BRA,00001,10,_IMM18:BRA:short:mu:JMP imm
# OBSOLETE "jmp <pcdisp>"
# OBSOLETE 	nia = pcaddr;
# OBSOLETE _BRA,00001,10,6.**,6.**,_IMM32:BRA:long:mu:JMP imm long
# OBSOLETE "jmp <pcdisp>"
# OBSOLETE 	nia = pcaddr;
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // JMPTNZ
# OBSOLETE 
# OBSOLETE _BRA,00101,01,6.RA,6.**,6.RC:BRA:short:mu:JMPTNZ
# OBSOLETE "jmptnz r<RC>"
# OBSOLETE 	if (val_Ra != 0)
# OBSOLETE 	  nia = pcaddr;
# OBSOLETE _BRA,00101,11,6.RA,_IMM12:BRA:short:mu:JMPTNZ imm
# OBSOLETE "jmptnz <pcdisp>"
# OBSOLETE 	if (val_Ra != 0)
# OBSOLETE 	  nia = pcaddr;
# OBSOLETE _BRA,00101,11,6.RA,6.**,_IMM32:BRA:long:mu:JMPTNZ imm long
# OBSOLETE "jmptnz <pcdisp>"
# OBSOLETE 	if (val_Ra != 0)
# OBSOLETE 	  nia = pcaddr;
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // JMPTZR
# OBSOLETE 
# OBSOLETE _BRA,00101,00,6.RA,6.**,6.RC:BRA:short:mu:JMPTZR
# OBSOLETE "jmptzr r<RC>"
# OBSOLETE 	if (val_Ra == 0)
# OBSOLETE 	  nia = pcaddr;
# OBSOLETE _BRA,00101,10,6.RA,_IMM12:BRA:short:mu:JMPTZR imm
# OBSOLETE "jmptzr <pcdisp>"
# OBSOLETE 	if (val_Ra == 0)
# OBSOLETE 	  nia = pcaddr;
# OBSOLETE _BRA,00101,10,6.RA,6.**,_IMM32:BRA:long:mu:JMPTZR imm long
# OBSOLETE "jmptzr <pcdisp>"
# OBSOLETE 	if (val_Ra == 0)
# OBSOLETE 	  nia = pcaddr;
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // JOINpp 
# OBSOLETE 
# OBSOLETE void::function::do_join_pp:int pp, unsigned32 *ra, unsigned32 rb, unsigned32 src
# OBSOLETE 	switch (pp) {
# OBSOLETE 	case 0x0: /* LL */
# OBSOLETE 	  WRITE32_QUEUE (ra, ((unsigned32)VL2_4(rb) << 16) | VL2_4(src));
# OBSOLETE 	  break;
# OBSOLETE 	case 0x1: /* LH */
# OBSOLETE 	  WRITE32_QUEUE (ra, ((unsigned32)VL2_4(rb) << 16) | VH2_4(src));
# OBSOLETE 	  break;
# OBSOLETE 	case 0x2: /* HL */
# OBSOLETE 	  WRITE32_QUEUE (ra, ((unsigned32)VH2_4(rb) << 16) | VL2_4(src));
# OBSOLETE 	  break;
# OBSOLETE 	case 0x3: /* HH */
# OBSOLETE 	  WRITE32_QUEUE (ra, ((unsigned32)VH2_4(rb) << 16) | VH2_4(src));
# OBSOLETE 	  break;
# OBSOLETE 	}
# OBSOLETE 
# OBSOLETE ::%s::pp:int pp
# OBSOLETE 	switch (pp)
# OBSOLETE 	  {
# OBSOLETE 	  case 0x0: return "ll";
# OBSOLETE 	  case 0x1: return "lh";
# OBSOLETE 	  case 0x2: return "hl";
# OBSOLETE 	  case 0x3: return "hh";
# OBSOLETE 	  default: return "?";
# OBSOLETE 	  }
# OBSOLETE 
# OBSOLETE _IALU1,011,pp,00,6.RA,6.RB,6.RC:IALU1:short:iu,mu:JOINpp
# OBSOLETE "join%s<pp> r<RA>, r<RB>, r<RC>"
# OBSOLETE 	do_join_pp(_SD, pp, Ra, Rb, Rc);
# OBSOLETE _IALU1,011,pp,10,6.RA,6.RB,_IMM6:IALU1:short:iu,mu:JOINpp imm
# OBSOLETE "join%s<pp> r<RA>, r<RB>, <imm>"
# OBSOLETE 	do_join_pp(_SD, pp, Ra, Rb, immHL);
# OBSOLETE _IALU1,011,pp,10,6.RA,6.RB,_IMM32:IALU1:long:iu,mu:JOINpp imm long
# OBSOLETE "join%s<pp> r<RA>, r<RB>, <imm>"
# OBSOLETE 	do_join_pp(_SD, pp, Ra, Rb, immHL);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // JSR
# OBSOLETE 
# OBSOLETE _BRA,00011,00,6.**,6.**,6.RC:BRA:short:mu:JSR
# OBSOLETE "jsr r<RC>"
# OBSOLETE 	if (cia == RPT_E && PSW_VAL (PSW_RP))
# OBSOLETE 	  WRITE32_QUEUE (&GPR[62], RPT_S);
# OBSOLETE 	else
# OBSOLETE 	  WRITE32_QUEUE (&GPR[62], cia + 8);
# OBSOLETE 	if (TRACE_CALL_P)
# OBSOLETE 	  TRACE_ACTION |= TRACE_ACTION_CALL;
# OBSOLETE 	return pcaddr;
# OBSOLETE _BRA,00011,10,_IMM18:BRA:short:mu:JSR imm
# OBSOLETE "jsr <pcdisp>"
# OBSOLETE 	if (cia == RPT_E && PSW_VAL (PSW_RP))
# OBSOLETE 	  WRITE32_QUEUE (&GPR[62], RPT_S);
# OBSOLETE 	else
# OBSOLETE 	  WRITE32_QUEUE (&GPR[62], cia + 8);
# OBSOLETE 	if (TRACE_CALL_P)
# OBSOLETE 	  TRACE_ACTION |= TRACE_ACTION_CALL;
# OBSOLETE 	return pcaddr;
# OBSOLETE _BRA,00011,10,6.**,6.**,_IMM32:BRA:long:mu:JSR imm long
# OBSOLETE "jsr <pcdisp>"
# OBSOLETE 	if (cia == RPT_E && PSW_VAL (PSW_RP))
# OBSOLETE 	  WRITE32_QUEUE (&GPR[62], RPT_S);
# OBSOLETE 	else
# OBSOLETE 	  WRITE32_QUEUE (&GPR[62], cia + 8);
# OBSOLETE 	if (TRACE_CALL_P)
# OBSOLETE 	  TRACE_ACTION |= TRACE_ACTION_CALL;
# OBSOLETE 	return pcaddr;
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // JSRTNZ
# OBSOLETE 
# OBSOLETE _BRA,00111,01,6.RA,6.**,6.RC:BRA:short:mu:JSRTNZ
# OBSOLETE "jsrtnz r<RC>"
# OBSOLETE 	if (val_Ra != 0) {
# OBSOLETE 	  if (cia == RPT_E && PSW_VAL (PSW_RP))
# OBSOLETE 	    WRITE32_QUEUE (&GPR[62], RPT_S);
# OBSOLETE 	  else
# OBSOLETE 	    WRITE32_QUEUE (&GPR[62], cia + 8);
# OBSOLETE 	  nia = pcaddr;
# OBSOLETE 	  if (TRACE_CALL_P)
# OBSOLETE 	    TRACE_ACTION |= TRACE_ACTION_CALL;
# OBSOLETE 	}
# OBSOLETE _BRA,00111,11,6.RA,_IMM12:BRA:short:mu:JSRTNZ imm
# OBSOLETE "jsrtnz <pcdisp>"
# OBSOLETE 	if (val_Ra != 0) {
# OBSOLETE 	  if (cia == RPT_E && PSW_VAL (PSW_RP))
# OBSOLETE 	    WRITE32_QUEUE (&GPR[62], RPT_S);
# OBSOLETE 	  else
# OBSOLETE 	    WRITE32_QUEUE (&GPR[62], cia + 8);
# OBSOLETE 	  nia = pcaddr;
# OBSOLETE 	  if (TRACE_CALL_P)
# OBSOLETE 	    TRACE_ACTION |= TRACE_ACTION_CALL;
# OBSOLETE 	}
# OBSOLETE _BRA,00111,11,6.RA,6.**,_IMM32:BRA:long:mu:JSRTNZ imm long
# OBSOLETE "jsrtnz <pcdisp>"
# OBSOLETE 	if (val_Ra != 0) {
# OBSOLETE 	  if (cia == RPT_E && PSW_VAL (PSW_RP))
# OBSOLETE 	    WRITE32_QUEUE (&GPR[62], RPT_S);
# OBSOLETE 	  else
# OBSOLETE 	    WRITE32_QUEUE (&GPR[62], cia + 8);
# OBSOLETE 	  nia = pcaddr;
# OBSOLETE 	  if (TRACE_CALL_P)
# OBSOLETE 	    TRACE_ACTION |= TRACE_ACTION_CALL;
# OBSOLETE 	}
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // JSRTZR
# OBSOLETE 
# OBSOLETE _BRA,00111,00,6.RA,6.**,6.RC:BRA:short:mu:JSRTZR
# OBSOLETE "jsrtzr r<RC>"
# OBSOLETE 	if (val_Ra == 0) {
# OBSOLETE 	  if (cia == RPT_E && PSW_VAL (PSW_RP))
# OBSOLETE 	    WRITE32_QUEUE (&GPR[62], RPT_S);
# OBSOLETE 	  else
# OBSOLETE 	    WRITE32_QUEUE (&GPR[62], cia + 8);
# OBSOLETE 	  nia = pcaddr;
# OBSOLETE 	  if (TRACE_CALL_P)
# OBSOLETE 	    TRACE_ACTION |= TRACE_ACTION_CALL;
# OBSOLETE 	}
# OBSOLETE _BRA,00111,10,6.RA,_IMM12:BRA:short:mu:JSRTZR imm
# OBSOLETE "jsrtzr <pcdisp>"
# OBSOLETE 	if (val_Ra == 0) {
# OBSOLETE 	  if (cia == RPT_E && PSW_VAL (PSW_RP))
# OBSOLETE 	    WRITE32_QUEUE (&GPR[62], RPT_S);
# OBSOLETE 	  else
# OBSOLETE 	    WRITE32_QUEUE (&GPR[62], cia + 8);
# OBSOLETE 	  nia = pcaddr;
# OBSOLETE 	  if (TRACE_CALL_P)
# OBSOLETE 	    TRACE_ACTION |= TRACE_ACTION_CALL;
# OBSOLETE 	}
# OBSOLETE _BRA,00111,10,6.RA,6.**,_IMM32:BRA:long:mu:JSRTZR imm long
# OBSOLETE "jsrtzr <pcdisp>"
# OBSOLETE 	if (val_Ra == 0) {
# OBSOLETE 	  if (cia == RPT_E && PSW_VAL (PSW_RP))
# OBSOLETE 	    WRITE32_QUEUE (&GPR[62], RPT_S);
# OBSOLETE 	  else
# OBSOLETE 	    WRITE32_QUEUE (&GPR[62], cia + 8);
# OBSOLETE 	  nia = pcaddr;
# OBSOLETE 	  if (TRACE_CALL_P)
# OBSOLETE 	    TRACE_ACTION |= TRACE_ACTION_CALL;
# OBSOLETE 	}
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // Post increment
# OBSOLETE 
# OBSOLETE void::function::do_incr:int x, unsigned32 *rb, int delta
# OBSOLETE 	unsigned32 next_rb;
# OBSOLETE 	if (x == 1)
# OBSOLETE 	  next_rb = *rb + delta;
# OBSOLETE 	else if (x == 3)
# OBSOLETE 	  next_rb = *rb - delta;
# OBSOLETE 	else
# OBSOLETE 	  next_rb = *rb; /* value not used */
# OBSOLETE 	/* HW erratum: check value after incrementing */
# OBSOLETE 	if (next_rb == MOD_E
# OBSOLETE 	    && (x == 1 || x == 3)
# OBSOLETE 	    && (PSW_VAL(PSW_MD))) {
# OBSOLETE 	  WRITE32_QUEUE (rb, MOD_S);
# OBSOLETE 	}
# OBSOLETE 	else if (x == 1 || x == 3)
# OBSOLETE 	  WRITE32_QUEUE (rb, next_rb);
# OBSOLETE 
# OBSOLETE // LD2H
# OBSOLETE 
# OBSOLETE int::function::make_even_reg:int reg, const char *name
# OBSOLETE 	if (reg & 1)
# OBSOLETE 	  sim_engine_abort (SD, CPU, cia,
# OBSOLETE 			    "0x%lx:%s odd register (r%d) used in multi-word load/mulx2h",
# OBSOLETE 			    (long) cia, name, reg);
# OBSOLETE 	return reg;
# OBSOLETE 
# OBSOLETE void::function::do_ld2h:int ra, unsigned32 rb, unsigned32 src
# OBSOLETE 	signed32 mem;
# OBSOLETE 	ra = make_even_reg(_SD, ra, "LD2H");
# OBSOLETE 	mem = MEM(signed, rb + src, 4);
# OBSOLETE 	if (ra != 0)
# OBSOLETE 	{
# OBSOLETE 	  WRITE32_QUEUE (&GPR[ra + 0], SEXT32(EXTRACTED32(mem, 0, 15), 16));
# OBSOLETE 	  WRITE32_QUEUE (&GPR[ra + 1], SEXT32(EXTRACTED32(mem, 16, 31), 16));
# OBSOLETE 	}
# OBSOLETE 
# OBSOLETE ::%s::XX:int XX
# OBSOLETE 	switch (XX)
# OBSOLETE 	  {
# OBSOLETE 	  case 0: return "";
# OBSOLETE 	  case 1: return "+";
# OBSOLETE 	  case 3: return "-";
# OBSOLETE 	  default: return "?";
# OBSOLETE 	  }
# OBSOLETE 
# OBSOLETE _IMEM,00011,XX,6.RA,6.RB,6.SRC_6:IMEM:short:mu:LD2H
# OBSOLETE "ld2h r<RA>, @(r<RB>, <SRC_6>)":XX == 0
# OBSOLETE "ld2h r<RA>, @(r<RB>%s<XX>, r<SRC_6>)"
# OBSOLETE 	do_ld2h(_SD, RA, Rb, src);
# OBSOLETE 	do_incr(_SD, XX, &GPR[RB], 4);
# OBSOLETE _IMEM,00011,10,6.RA,6.RB,_IMM32:IMEM:long:mu:LD2H long
# OBSOLETE "ld2h r<RA>, @(r<RB>, <imm>)"
# OBSOLETE 	do_ld2h(_SD, RA, Rb, imm);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // LD2W
# OBSOLETE 
# OBSOLETE void::function::do_ld2w:int ra, unsigned32 rb, unsigned32 src
# OBSOLETE 	unsigned64 mem;
# OBSOLETE 	ra = make_even_reg(_SD, ra, "LD2W");
# OBSOLETE 	mem = MEM(unsigned, rb + src, 8);
# OBSOLETE 	if (ra != 0)
# OBSOLETE 	{
# OBSOLETE 	  WRITE32_QUEUE (&GPR[ra + 0], EXTRACTED64 (mem, 0, 31));
# OBSOLETE 	  WRITE32_QUEUE (&GPR[ra + 1], EXTRACTED64 (mem, 32, 63));
# OBSOLETE 	}
# OBSOLETE 
# OBSOLETE _IMEM,00110,XX,6.RA,6.RB,6.SRC_6:IMEM:short:mu:L2W
# OBSOLETE "ld2w r<RA>, @(r<RB>, <SRC_6>)":XX == 0
# OBSOLETE "ld2w r<RA>, @(r<RB>%s<XX>, r<SRC_6>)"
# OBSOLETE 	do_ld2w(_SD, RA, Rb, src);
# OBSOLETE 	do_incr(_SD, XX, &GPR[RB], 8);
# OBSOLETE _IMEM,00110,10,6.RA,6.RB,_IMM32:IMEM:long:mu:L2W long
# OBSOLETE "ld2w r<RA>, @(r<RB>, <imm>)"
# OBSOLETE 	do_ld2w(_SD, RA, Rb, imm);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // LD4BH
# OBSOLETE 
# OBSOLETE void::function::do_ld4bh:unsigned32 ra, unsigned32 rb, unsigned32 src
# OBSOLETE 	unsigned16 l1, l2, h1, h2;
# OBSOLETE 	unsigned32 mem;
# OBSOLETE 	ra = make_even_reg(_SD, ra, "LD4BH");
# OBSOLETE 	mem = MEM(unsigned, rb + src, 4);
# OBSOLETE 	h1 = SEXT16(EXTRACTED32(mem, 0, 7), 8);
# OBSOLETE 	l1 = SEXT16(EXTRACTED32(mem, 8, 15), 8);
# OBSOLETE 	h2 = SEXT16(EXTRACTED32(mem, 16, 23), 8);
# OBSOLETE 	l2 = SEXT16(EXTRACTED32(mem, 24, 31), 8);
# OBSOLETE 	if (ra != 0)
# OBSOLETE 	{
# OBSOLETE 	  WRITE32_QUEUE (&GPR[ra + 0], (h1 << 16) | l1);
# OBSOLETE 	  WRITE32_QUEUE (&GPR[ra + 1], (h2 << 16) | l2);
# OBSOLETE 	}
# OBSOLETE 
# OBSOLETE _IMEM,00101,XX,6.RA,6.RB,6.SRC_6:IMEM:short:mu:LD4BH
# OBSOLETE "ld4bh r<RA>, @(r<RB>, <SRC_6>)":XX == 0
# OBSOLETE "ld4bh r<RA>, @(r<RB>%s<XX>, r<SRC_6>)"
# OBSOLETE 	do_ld4bh(_SD, RA, Rb, src);
# OBSOLETE 	do_incr(_SD, XX, &GPR[RB], 4);
# OBSOLETE _IMEM,00101,10,6.RA,6.RB,_IMM32:IMEM:long:mu:LD4BH long
# OBSOLETE "ld4bh r<RA>, @(r<RB>, <imm>)"
# OBSOLETE 	do_ld4bh(_SD, RA, Rb, imm);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // LD4BHU
# OBSOLETE 
# OBSOLETE void::function::do_ld4bhu:unsigned32 ra, unsigned32 rb, unsigned32 src
# OBSOLETE 	unsigned16 l1, l2, h1, h2;
# OBSOLETE 	unsigned32 mem;
# OBSOLETE 	ra = make_even_reg(_SD, ra, "LD4BH");
# OBSOLETE 	mem = MEM(signed, rb + src, 4);
# OBSOLETE 	h1 = EXTRACTED32(mem, 0, 7);
# OBSOLETE 	l1 = EXTRACTED32(mem, 8, 15);
# OBSOLETE 	h2 = EXTRACTED32(mem, 16, 23);
# OBSOLETE 	l2 = EXTRACTED32(mem, 24, 31);
# OBSOLETE 	if (ra != 0)
# OBSOLETE 	{
# OBSOLETE 	  WRITE32_QUEUE (&GPR[ra + 0], (h1 << 16) | l1);
# OBSOLETE 	  WRITE32_QUEUE (&GPR[ra + 1], (h2 << 16) | l2);
# OBSOLETE 	}
# OBSOLETE 
# OBSOLETE _IMEM,01101,XX,6.RA,6.RB,6.SRC_6:IMEM:short:mu:LD4BHU
# OBSOLETE "ld4hbu r<RA>, @(r<RB>, <SRC_6>)":XX == 0
# OBSOLETE "ld4hbu r<RA>, @(r<RB>%s<XX>, r<SRC_6>)"
# OBSOLETE 	do_ld4bhu(_SD, RA, Rb, src);
# OBSOLETE 	do_incr(_SD, XX, &GPR[RB], 4);
# OBSOLETE _IMEM,01101,10,6.RA,6.RB,_IMM32:IMEM:long:mu:LD4BHU long
# OBSOLETE "ld4hbu r<RA>, @(r<RB>, <imm>)"
# OBSOLETE 	do_ld4bhu(_SD, RA, Rb, imm);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // LDB
# OBSOLETE 
# OBSOLETE void::function::do_ldb:unsigned32 *ra, unsigned32 rb, unsigned32 src
# OBSOLETE 	WRITE32_QUEUE (ra, MEM(signed, rb + src, 1));
# OBSOLETE 
# OBSOLETE _IMEM,00000,XX,6.RA,6.RB,6.SRC_6:IMEM:short:mu:LDB
# OBSOLETE "ldb r<RA>, @(r<RB>, <SRC_6>)":XX == 0
# OBSOLETE "ldb r<RA>, @(r<RB>%s<XX>, r<SRC_6>)"
# OBSOLETE 	do_ldb(_SD, Ra, Rb, src);
# OBSOLETE 	do_incr(_SD, XX, &GPR[RB], 1);
# OBSOLETE _IMEM,00000,10,6.RA,6.RB,_IMM32:IMEM:long:mu:LDB long
# OBSOLETE "ldb r<RA>, @(r<RB>, <imm>)"
# OBSOLETE 	do_ldb(_SD, Ra, Rb, imm);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // LDBU
# OBSOLETE 
# OBSOLETE void::function::do_ldbu:unsigned32 *ra, unsigned32 rb, unsigned32 src
# OBSOLETE 	WRITE32_QUEUE (ra, MEM(unsigned, rb + src, 1));
# OBSOLETE 
# OBSOLETE _IMEM,01001,XX,6.RA,6.RB,6.SRC_6:IMEM:short:mu:LDBU
# OBSOLETE "ldbu r<RA>, @(r<RB>, <SRC_6>)":XX == 0
# OBSOLETE "ldbu r<RA>, @(r<RB>%s<XX>, r<SRC_6>)"
# OBSOLETE 	do_ldbu(_SD, Ra, Rb, src);
# OBSOLETE 	do_incr(_SD, XX, &GPR[RB], 1);
# OBSOLETE _IMEM,01001,10,6.RA,6.RB,_IMM32:IMEM:long:mu:LDBU long
# OBSOLETE "ldbu r<RA>, @(r<RB>, <imm>)"
# OBSOLETE 	do_ldbu(_SD, Ra, Rb, imm);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // LDH
# OBSOLETE 
# OBSOLETE void::function::do_ldh:unsigned32 *ra, unsigned32 rb, unsigned32 src
# OBSOLETE 	WRITE32_QUEUE (ra, MEM(signed, rb + src, 2));
# OBSOLETE 
# OBSOLETE _IMEM,00010,XX,6.RA,6.RB,6.SRC_6:IMEM:short:mu:LDH
# OBSOLETE "ldh r<RA>, @(r<RB>, <SRC_6>)":XX == 0
# OBSOLETE "ldh r<RA>, @(r<RB>%s<XX>, r<SRC_6>)"
# OBSOLETE 	do_ldh(_SD, Ra, Rb, src);
# OBSOLETE 	do_incr(_SD, XX, &GPR[RB], 2);
# OBSOLETE _IMEM,00010,10,6.RA,6.RB,_IMM32:IMEM:long:mu:LDH long
# OBSOLETE "ldh r<RA>, @(r<RB>, <imm>)"
# OBSOLETE 	do_ldh(_SD, Ra, Rb, imm);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // LDHH
# OBSOLETE 
# OBSOLETE void::function::do_ldhh:unsigned32 *ra, unsigned32 rb, unsigned32 src
# OBSOLETE 	WRITE32_QUEUE (ra, MEM(signed, rb + src, 2) << 16);
# OBSOLETE 
# OBSOLETE _IMEM,00001,XX,6.RA,6.RB,6.SRC_6:IMEM:short:mu:LDHH
# OBSOLETE "ldhh r<RA>, @(r<RB>, <SRC_6>)":XX == 0
# OBSOLETE "ldhh r<RA>, @(r<RB>%s<XX>, r<SRC_6>)"
# OBSOLETE 	do_ldhh(_SD, Ra, Rb, src);
# OBSOLETE 	do_incr(_SD, XX, &GPR[RB], 2);
# OBSOLETE _IMEM,00001,10,6.RA,6.RB,_IMM32:IMEM:long:mu:LDHH long
# OBSOLETE "ldhh r<RA>, @(r<RB>, <imm>)"
# OBSOLETE 	do_ldhh(_SD, Ra, Rb, imm);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // LDHU
# OBSOLETE 
# OBSOLETE void::function::do_ldhu:unsigned32 *ra, unsigned32 rb, unsigned32 src
# OBSOLETE 	WRITE32_QUEUE (ra, MEM(unsigned, rb + src, 2));
# OBSOLETE 
# OBSOLETE _IMEM,01010,XX,6.RA,6.RB,6.SRC_6:IMEM:short:mu:LDHU
# OBSOLETE "ldhu r<RA>, @(r<RB>, <SRC_6>)":XX == 0
# OBSOLETE "ldhu r<RA>, @(r<RB>%s<XX>, r<SRC_6>)"
# OBSOLETE 	do_ldhu(_SD, Ra, Rb, src);
# OBSOLETE 	do_incr(_SD, XX, &GPR[RB], 2);
# OBSOLETE _IMEM,01010,10,6.RA,6.RB,_IMM32:IMEM:long:mu:LDHU long
# OBSOLETE "ldhu r<RA>, @(r<RB>, <imm>)"
# OBSOLETE 	do_ldhu(_SD, Ra, Rb, imm);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // LDW
# OBSOLETE 
# OBSOLETE void::function::do_ldw:unsigned32 *ra, unsigned32 rb, unsigned32 src
# OBSOLETE 	WRITE32_QUEUE (ra, MEM(signed, rb + src, 4));
# OBSOLETE 
# OBSOLETE _IMEM,00100,XX,6.RA,6.RB,6.SRC_6:IMEM:short:mu:LDW
# OBSOLETE "ldw r<RA>, @(r<RB>, <SRC_6>)":XX == 0
# OBSOLETE "ldw r<RA>, @(r<RB>%s<XX>, r<SRC_6>)"
# OBSOLETE 	do_ldw(_SD, Ra, Rb, src);
# OBSOLETE 	do_incr(_SD, XX, &GPR[RB], 4);
# OBSOLETE _IMEM,00100,10,6.RA,6.RB,_IMM32:IMEM:long:mu:LDW long
# OBSOLETE "ldw r<RA>, @(r<RB>, <imm>)"
# OBSOLETE 	do_ldw(_SD, Ra, Rb, imm);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // MACa
# OBSOLETE 
# OBSOLETE void::function::do_mac:unsigned64 *aa, unsigned32 *ra, signed32 rb, signed32 src
# OBSOLETE 	unsigned64 accum = *aa;
# OBSOLETE 	accum += (signed64) (rb) * (signed64) (src);
# OBSOLETE 	WRITE64_QUEUE (aa, accum);
# OBSOLETE 	WRITE32_QUEUE (ra, EXTRACTED64(accum, 32, 63));
# OBSOLETE 
# OBSOLETE _IALU2,10100,0,1.AA,6.RA,6.RB,6.RC:IALU2:short:iu:MACa
# OBSOLETE "mac<AA> r<RA>, r<RB>, r<RC>"
# OBSOLETE 	do_mac(_SD, Aa, Ra, Rb, Rc);	
# OBSOLETE _IALU2,10100,1,1.AA,6.RA,6.RB,_IMM6:IALU2:short:iu:MACa imm
# OBSOLETE "mac<AA> r<RA>, r<RB>, <imm>"
# OBSOLETE 	do_mac(_SD, Aa, Ra, Rb, imm);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // MACSa
# OBSOLETE 
# OBSOLETE void::function::do_macs:unsigned64 *aa, unsigned32 *ra, signed32 rb, signed32 src
# OBSOLETE 	unsigned64 accum = *aa;
# OBSOLETE 	accum += ((signed64) (rb) * (signed64) (src)) << 1;
# OBSOLETE 	WRITE64_QUEUE (aa, accum);
# OBSOLETE 	WRITE32_QUEUE (ra, EXTRACTED64(accum, 0, 31));
# OBSOLETE 
# OBSOLETE _IALU2,10101,0,1.AA,6.RA,6.RB,6.RC:IALU2:short:iu:MACSa
# OBSOLETE "macs<AA> r<RA>, r<RB>, r<RC>"
# OBSOLETE 	do_macs(_SD, Aa, Ra, Rb, Rc);	
# OBSOLETE _IALU2,10101,1,1.AA,6.RA,6.RB,_IMM6:IALU2:short:iu:MACSa imm
# OBSOLETE "macs<AA> r<RA>, r<RB>, <imm>"
# OBSOLETE 	do_macs(_SD, Aa, Ra, Rb, imm);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // MODDEC | MODINC
# OBSOLETE 
# OBSOLETE _IMEM,00111,11,6.**,6.RB,_IMM6:IMEM:short:mu:MODDEC
# OBSOLETE "moddec r<RB>, <imm>"
# OBSOLETE 	do_incr(_SD, 3/*0b11*/, &GPR[RB], imm_5);	
# OBSOLETE _IMEM,00111,01,6.**,6.RB,_IMM6:IMEM:short:mu:MODINC
# OBSOLETE "modinc r<RB>, <imm>"
# OBSOLETE 	do_incr(_SD, 1/*0b01*/, &GPR[RB], imm_5);	
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // MSUBa
# OBSOLETE 
# OBSOLETE void::function::do_msub:unsigned64 *aa, unsigned32 *ra, signed32 rb, signed32 src
# OBSOLETE 	unsigned64 accum = *aa;
# OBSOLETE 	accum -= (signed64) (rb) * (signed64) (src);
# OBSOLETE 	WRITE64_QUEUE (aa, accum);
# OBSOLETE 	WRITE32_QUEUE (ra, EXTRACTED64(accum, 32, 63));
# OBSOLETE 
# OBSOLETE _IALU2,10110,0,1.AA,6.RA,6.RB,6.RC:IALU2:short:iu:MSUBa
# OBSOLETE "msub<AA> r<RA>, r<RB>, r<RC>"
# OBSOLETE 	do_msub(_SD, Aa, Ra, Rb, Rc);	
# OBSOLETE _IALU2,10110,1,1.AA,6.RA,6.RB,_IMM6:IALU2:short:iu:MSUBa imm
# OBSOLETE "msub<AA> r<RA>, r<RB>, <imm>"
# OBSOLETE 	do_msub(_SD, Aa, Ra, Rb, imm);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // MSUBSa
# OBSOLETE 
# OBSOLETE void::function::do_msubs:unsigned64 *aa, unsigned32 *ra, signed32 rb, signed32 src
# OBSOLETE 	unsigned64 accum = *aa;
# OBSOLETE 	accum -= ((signed64) (rb) * (signed64) (src)) << 1;
# OBSOLETE 	WRITE64_QUEUE (aa, accum);
# OBSOLETE 	WRITE32_QUEUE (ra, EXTRACTED64(accum, 0, 31));
# OBSOLETE 
# OBSOLETE _IALU2,10111,0,1.AA,6.RA,6.RB,6.RC:IALU2:short:iu:MSUBSa
# OBSOLETE "msubs<AA> r<RA>, r<RB>, r<RC>"
# OBSOLETE 	do_msubs(_SD, Aa, Ra, Rb, Rc);	
# OBSOLETE _IALU2,10111,1,1.AA,6.RA,6.RB,_IMM6:IALU2:short:iu:MSUBSa imm
# OBSOLETE "msubs<AA> r<RA>, r<RB>, <imm>"
# OBSOLETE 	do_msubs(_SD, Aa, Ra, Rb, imm);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // MUL
# OBSOLETE 
# OBSOLETE void::function::do_mul:unsigned32 *ra, unsigned32 rb, unsigned32 src
# OBSOLETE 	WRITE32_QUEUE (ra, rb * src);
# OBSOLETE 
# OBSOLETE _IALU2,10000,00,6.RA,6.RB,6.RC:IALU2:short:iu:MUL
# OBSOLETE "mul r<RA>, r<RB>, r<RC>"
# OBSOLETE 	do_mul(_SD, Ra, Rb, Rc);	
# OBSOLETE _IALU2,10000,10,6.RA,6.RB,_IMM6:IALU2:short:iu:MUL imm
# OBSOLETE "mul r<RA>, r<RB>, <imm>"
# OBSOLETE 	do_mul(_SD, Ra, Rb, imm);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // MUL2H
# OBSOLETE 
# OBSOLETE void::function::do_mul2h:unsigned32 *ra, unsigned32 rb, unsigned32 src
# OBSOLETE 	unsigned16 high = VH2_4(rb) * VH2_4(src);
# OBSOLETE 	unsigned16 low  = VL2_4(rb) * VL2_4(src);
# OBSOLETE 	WRITE32_QUEUE (ra, (high << 16) | low);
# OBSOLETE 
# OBSOLETE _IALU2,00000,00,6.RA,6.RB,6.RC:IALU2:short:iu:MUL2H
# OBSOLETE "mul2h r<RA>, r<RB>, r<RC>"
# OBSOLETE 	do_mul2h(_SD, Ra, Rb, Rc);	
# OBSOLETE _IALU2,00000,10,6.RA,6.RB,_IMM6:IALU2:short:iu:MUL2H imm
# OBSOLETE "mul2h r<RA>, r<RB>, <imm>"
# OBSOLETE 	do_mul2h(_SD, Ra, Rb, immHL);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // MULX
# OBSOLETE 
# OBSOLETE void::function::do_mulx:unsigned64 *aa, signed32 rb, signed32 src
# OBSOLETE 	WRITE64_QUEUE (aa, (signed64) (rb) * (signed64) (src));
# OBSOLETE 
# OBSOLETE _IALU2,11000,00,5.*,1.AA,6.RB,6.RC:IALU2:short:iu:MULX
# OBSOLETE "mulx a<AA>, r<RB>, r<RC>"
# OBSOLETE 	do_mulx(_SD, Aa, Rb, Rc);	
# OBSOLETE _IALU2,11000,10,5.*,1.AA,6.RB,_IMM6:IALU2:short:iu:MULX imm
# OBSOLETE "mulx a<AA>, r<RB>, <imm>"
# OBSOLETE 	do_mulx(_SD, Aa, Rb, imm);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // MULX2H
# OBSOLETE 
# OBSOLETE void::function::do_mulx2h:int ra, signed32 rb, signed32 src, int high
# OBSOLETE 	signed32 result = rb * src;
# OBSOLETE 	if (!high)
# OBSOLETE 	  {
# OBSOLETE 	    ra = make_even_reg(_SD, ra, "MULX2H");
# OBSOLETE 	    if (ra != 0)
# OBSOLETE 	      WRITE32_QUEUE (&GPR[ra+1], result);
# OBSOLETE 	  }
# OBSOLETE 	else if (ra != 0)
# OBSOLETE 	  {
# OBSOLETE 	      WRITE32_QUEUE (&GPR[ra+0], result);
# OBSOLETE 	  }
# OBSOLETE 
# OBSOLETE _IALU2,00001,00,6.RA,6.RB,6.RC:IALU2:short:iu:MULX2H
# OBSOLETE "mul2h r<RA>, r<RB>, r<RC>"
# OBSOLETE 	do_mulx2h(_SD, RA, RbH, RcH, 1);
# OBSOLETE 	do_mulx2h(_SD, RA, RbL, RcL, 0);
# OBSOLETE _IALU2,00001,10,6.RA,6.RB,_IMM6:IALU2:short:iu:MULX2H imm
# OBSOLETE "mul2h r<RA>, r<RB>, <imm>"
# OBSOLETE 	do_mulx2h(_SD, RA, RbH, imm, 1);
# OBSOLETE 	do_mulx2h(_SD, RA, RbL, imm, 0);
# OBSOLETE 
# OBSOLETE // MULHXpp
# OBSOLETE 
# OBSOLETE void::function::do_mulhx:int pp, unsigned32 *ra, unsigned32 rb, unsigned32 src
# OBSOLETE 	signed32 value = 0;
# OBSOLETE 	switch (pp) {
# OBSOLETE 	case 0: /* LL */
# OBSOLETE 	  value = SEXT32(VL2_4(rb), 16) * SEXT32(VL2_4(src), 16);
# OBSOLETE 	  break;
# OBSOLETE 	case 1: /* LH */
# OBSOLETE 	  value = SEXT32(VL2_4(rb), 16) * SEXT32(VH2_4(src), 16);
# OBSOLETE 	  break;
# OBSOLETE 	case 2: /* HL */
# OBSOLETE 	  value = SEXT32(VH2_4(rb), 16) * SEXT32(VL2_4(src), 16);
# OBSOLETE 	  break;
# OBSOLETE 	case 3: /* HH */
# OBSOLETE 	  value = SEXT32(VH2_4(rb), 16) * SEXT32(VH2_4(src), 16);
# OBSOLETE 	  break;
# OBSOLETE 	default:
# OBSOLETE 	  sim_engine_abort (SD, CPU, cia, "do_mulhx - internal error - bad switch");
# OBSOLETE 	}
# OBSOLETE 	WRITE32_QUEUE (ra, value);
# OBSOLETE 
# OBSOLETE _IALU2,001,pp,00,6.RA,6.RB,6.RC:IALU2:short:iu:MULHXpp
# OBSOLETE "mulhx%s<pp> r<RA>, r<RB>, r<RC>"
# OBSOLETE 	do_mulhx(_SD, pp, Ra, Rb, Rc);	
# OBSOLETE _IALU2,001,pp,10,6.RA,6.RB,_IMM6:IALU2:short:iu:MULHXpp imm
# OBSOLETE "mulhx%s<pp> r<RA>, r<RB>, <imm>"
# OBSOLETE 	do_mulhx(_SD, pp, Ra, Rb, immHL);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // MULXS
# OBSOLETE 
# OBSOLETE void::function::do_mulxs:unsigned64 *aa, signed32 rb, signed32 src
# OBSOLETE 	WRITE64_QUEUE (aa, ((signed64) (rb) * (signed64) (src)) << 1);
# OBSOLETE 
# OBSOLETE _IALU2,11001,00,5.*,1.AA,6.RB,6.RC:IALU2:short:iu:MULXS
# OBSOLETE "mulxs a<AA>, r<RB>, r<RC>"
# OBSOLETE 	do_mulxs(_SD, Aa, Rb, Rc);	
# OBSOLETE _IALU2,11001,10,5.*,1.AA,6.RB,_IMM6:IALU2:short:iu:MULXS imm
# OBSOLETE "mulxs a<AA>, r<RB>, <imm>"
# OBSOLETE 	do_mulxs(_SD, Aa, Rb, imm);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // MVFACC
# OBSOLETE 
# OBSOLETE void::function::do_mvfacc:unsigned32 *ra, unsigned64 ab, unsigned32 src
# OBSOLETE 	while (src > 63) src -= 64;
# OBSOLETE 	WRITE32_QUEUE (ra, ((signed64)ab) >> src);
# OBSOLETE 
# OBSOLETE _IALU2,11111,00,6.RA,5.*,1.AB,6.RC:IALU2:short:iu:MVFACC
# OBSOLETE "mvfacc r<RA>, a<AB>, r<RC>"
# OBSOLETE 	do_mvfacc(_SD, Ra, *Ab, Rc);	
# OBSOLETE _IALU2,11111,10,6.RA,5.*,1.AB,_IMM6:IALU2:short:iu:MVFACC imm
# OBSOLETE "mvfacc r<RA>, a<AB>, <imm>"
# OBSOLETE 	do_mvfacc(_SD, Ra, *Ab, imm_6u);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // MVFSYS
# OBSOLETE 
# OBSOLETE _BRA,11110,00,6.RA,6.CR,6.ID:BRA:short:mu:MVFSYS
# OBSOLETE "mvfsys r<RA>, cr<CR>"
# OBSOLETE 	switch (ID) {
# OBSOLETE 	case 0:
# OBSOLETE 	  if (CR >= NR_CONTROL_REGISTERS)
# OBSOLETE 	    sim_engine_abort (SD, CPU, cia, "FIXME - illegal CR");
# OBSOLETE 	  else
# OBSOLETE 	    WRITE32_QUEUE (Ra, (CPU)->regs.control[CR]);
# OBSOLETE 	  break;
# OBSOLETE 	case 1:
# OBSOLETE 	  WRITE32_QUEUE (Ra, PSWL);
# OBSOLETE 	  break;
# OBSOLETE 	case 2:
# OBSOLETE 	  WRITE32_QUEUE (Ra, EXTRACTED32(PSWH, 16, 31));
# OBSOLETE 	  break;
# OBSOLETE 	case 3:
# OBSOLETE 	  WRITE32_QUEUE (Ra, PSW_FLAG_VAL(CR));
# OBSOLETE 	  break;
# OBSOLETE 	default:
# OBSOLETE 	  sim_engine_abort (SD, CPU, cia, "FIXME - illegal ID");
# OBSOLETE 	}
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // MVTACC
# OBSOLETE 
# OBSOLETE _IALU2,01111,00,5.*,1.AA,6.RB,6.RC:IALU2:short:iu:MVTACC
# OBSOLETE "mvtacc a<AA>, r<RB>, r<RC>"
# OBSOLETE 	WRITE64_QUEUE (Aa, INSERTED64(RbU, 0, 31) | (RcU));
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // MVTSYS
# OBSOLETE 
# OBSOLETE _BRA,01110,00,6.CR,6.RB,6.ID:BRA:short:mu:MVTSYS
# OBSOLETE "mvtsys cr<CR>, r<RB>"
# OBSOLETE 	switch (ID) {
# OBSOLETE 	case 0:			/* control register */
# OBSOLETE 	  if (CR >= NR_CONTROL_REGISTERS)
# OBSOLETE 	    sim_engine_abort (SD, CPU, cia, "FIXME - illegal CR");
# OBSOLETE 	  else
# OBSOLETE 	    {
# OBSOLETE 	      unsigned32 value = Rb;
# OBSOLETE 	      CPU->mvtsys_left_p = 1;
# OBSOLETE 	      if (CR == processor_status_word_cr)
# OBSOLETE 		{
# OBSOLETE 		  unsigned32 ds = PSW & BIT32 (PSW_DS);	/* preserve ds */
# OBSOLETE 		  value = ds | (value & PSW_VALID);
# OBSOLETE 		}
# OBSOLETE 	      else if (CR == backup_processor_status_word_cr
# OBSOLETE 		       || CR == debug_backup_processor_status_word_cr)
# OBSOLETE 		value &= DPSW_VALID;
# OBSOLETE 	      else if (CR == eit_vector_base_cr)
# OBSOLETE 		value &= EIT_VALID;
# OBSOLETE 	      WRITE32_QUEUE (&(CPU)->regs.control[CR], value);
# OBSOLETE 	    }
# OBSOLETE 	  break;
# OBSOLETE 	case 1:			/* PSWL */
# OBSOLETE 	  WRITE32_QUEUE_MASK (&PSW, EXTRACTED32(Rb, 16, 31),
# OBSOLETE 			      PSW_VALID & 0x0000ffff);
# OBSOLETE 	  break;
# OBSOLETE 	case 2:			/* PSWH */
# OBSOLETE 	  {
# OBSOLETE 	    unsigned32 ds = PSW & BIT32 (PSW_DS);	/* preserve ds */
# OBSOLETE 	    WRITE32_QUEUE_MASK (&PSW, (EXTRACTED32(Rb, 16, 31) << 16) | ds,
# OBSOLETE 				(PSW_VALID | ds) & 0xffff0000);
# OBSOLETE 	  }
# OBSOLETE 	  break;
# OBSOLETE 	case 3:			/* FLAG */
# OBSOLETE 	  PSW_FLAG_SET_QUEUE(CR, Rb & 1);
# OBSOLETE 	  break;
# OBSOLETE 	default:
# OBSOLETE 	  sim_engine_abort (SD, CPU, cia, "FIXME - illegal ID");
# OBSOLETE 	}
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // NOP
# OBSOLETE 
# OBSOLETE _BRA,01111,00,6.**,6.**,6.**:BRA:short:iu,mu:NOP
# OBSOLETE "nop"
# OBSOLETE 	/* NOP */;
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // NOT
# OBSOLETE 
# OBSOLETE _LOGIC,11001,00,6.RA,6.RB,6.*:LOGIC:short:iu,mu:NOT
# OBSOLETE "not r<RA>, r<RB>"
# OBSOLETE 	WRITE32_QUEUE (Ra, ~Rb);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // NOTFG
# OBSOLETE 
# OBSOLETE _LOGIC,01001,00,***,3.FA,***,3.FB,***,3.FC:LOGIC:short:iu,mu:NOTFG
# OBSOLETE "notfg f<FA>, f<FB>"
# OBSOLETE 	PSW_FLAG_SET_QUEUE(FA, !PSW_FLAG_VAL(FB));
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // OR
# OBSOLETE 
# OBSOLETE _LOGIC,11010,00,6.RA,6.RB,6.RC:LOGIC:short:iu,mu:OR
# OBSOLETE "or r<RA>, r<RB>, r<RC>"
# OBSOLETE 	WRITE32_QUEUE (Ra, Rb | Rc);
# OBSOLETE _LOGIC,11010,10,6.RA,6.RB,_IMM6:LOGIC:short:iu,mu:OR imm
# OBSOLETE "or r<RA>, r<RB>, <imm>"
# OBSOLETE 	WRITE32_QUEUE (Ra, Rb | imm);
# OBSOLETE _LOGIC,11010,10,6.RA,6.RB,_IMM32:LOGIC:long:iu,mu:OR imm long
# OBSOLETE "or r<RA>, r<RB>, <imm>"
# OBSOLETE 	WRITE32_QUEUE (Ra, Rb | imm);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // ORFG
# OBSOLETE 
# OBSOLETE _LOGIC,01010,00,***,3.FA,***,3.FB,***,3.FC:LOGIC:short:iu,mu:ORFG
# OBSOLETE "orfg f<FA>, f<FB>, f<FC>"
# OBSOLETE 	PSW_FLAG_SET_QUEUE(FA, PSW_FLAG_VAL(FB) | PSW_FLAG_VAL(FC));
# OBSOLETE _LOGIC,01010,10,***,3.FA,***,3.FB,_IMM6:LOGIC:short:iu,mu:ORFG imm
# OBSOLETE "orfg f<FA>, f<FB>, <imm>"
# OBSOLETE 	PSW_FLAG_SET_QUEUE(FA, PSW_FLAG_VAL(FB) | (imm_6 & 1));
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // REIT
# OBSOLETE 
# OBSOLETE _BRA,01000,00,6.**,6.**,6.**:BRA:short:mu:REIT
# OBSOLETE "reit"
# OBSOLETE 	WRITE32_QUEUE (&PSW, bPSW);
# OBSOLETE 	nia = bPC;
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // REPEAT
# OBSOLETE 
# OBSOLETE void::function::do_repeat:unsigned32 count, address_word pcaddr
# OBSOLETE 	address_word rpt_s = cia + 8;
# OBSOLETE 	address_word rpt_e = cia + pcaddr;
# OBSOLETE 
# OBSOLETE 	if (count == 0)
# OBSOLETE 	  sim_engine_abort (SD, CPU, cia, "REPEAT with ra=0 and REPEATI with imm = 0 is forbidden.");
# OBSOLETE 	if (count > 1)
# OBSOLETE 	  PSW_SET_QUEUE (PSW_RP, 1);
# OBSOLETE 	if (rpt_e  < rpt_s + 0x10)
# OBSOLETE 	  sim_io_eprintf (sd, "warning: 0x%lx: REPEAT or REPEATI loop is too small\n", (long) cia);
# OBSOLETE 	WRITE32_QUEUE (&RPT_C, count - 1);
# OBSOLETE 	WRITE32_QUEUE (&RPT_S, rpt_s);
# OBSOLETE 	WRITE32_QUEUE (&RPT_E, rpt_e);
# OBSOLETE 
# OBSOLETE _BRA,11000,00,6.RA,6.**,6.RC:BRA:short:mu:REPEAT
# OBSOLETE "repeat r<RA>, r<RC>"
# OBSOLETE 	do_repeat(_SD, val_Ra, pcaddr);
# OBSOLETE _BRA,11000,10,6.RA,_IMM12:BRA:short:mu:REPEAT imm
# OBSOLETE "repeat r<RA>, <pcaddr>"
# OBSOLETE 	do_repeat(_SD, val_Ra, pcaddr);
# OBSOLETE _BRA,11000,10,6.RA,6.**,_IMM32:BRA:long:mu:REPEAT imm long
# OBSOLETE "repeat r<RA>, <pcaddr>"
# OBSOLETE 	do_repeat(_SD, val_Ra, pcaddr);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // REPEATI
# OBSOLETE 
# OBSOLETE _BRA,11010,00,6.IMM_6,6.**,6.RC:BRA:short:mu:REPEATI
# OBSOLETE "repeati <IMM_6>, r<RC>"
# OBSOLETE 	do_repeat(_SD, IMM_6, pcaddr);
# OBSOLETE _BRA,11010,10,6.IMM_6,_IMM12:BRA:short:mu:REPEATI imm
# OBSOLETE "repeati <IMM_6>, <pcaddr>"
# OBSOLETE 	do_repeat(_SD, IMM_6, pcaddr);
# OBSOLETE _BRA,11010,10,6.IMM_6,6.**,_IMM32:BRA:long:mu:REPEATI imm long
# OBSOLETE "repeati <IMM_6>, <pcaddr>"
# OBSOLETE 	do_repeat(_SD, IMM_6, pcaddr);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // RTD
# OBSOLETE 
# OBSOLETE _BRA,01010,00,6.*,6.*,6.*:BRA:short:mu:RTD
# OBSOLETE "rtd"
# OBSOLETE 	WRITE32_QUEUE (&PSW, DPSW);
# OBSOLETE 	nia = DPC;
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // ROT
# OBSOLETE 
# OBSOLETE _LOGIC,10100,00,6.RA,6.RB,6.RC:LOGIC:short:iu,mu:ROT
# OBSOLETE "rot r<RA>, r<RB>, r<RC>"
# OBSOLETE 	WRITE32_QUEUE (Ra, ROT32(Rb, Rc & 0x1f));
# OBSOLETE _LOGIC,10100,10,6.RA,6.RB,_IMM6:LOGIC:short:iu,mu:ROT imm
# OBSOLETE "rot r<RA>, r<RB>, <imm>"
# OBSOLETE 	WRITE32_QUEUE (Ra, ROT32(Rb, imm & 0x1f));
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // ROT2H
# OBSOLETE 
# OBSOLETE void::function::do_rot2h:unsigned32 *ra, unsigned32 rb, signed32 src
# OBSOLETE 	unsigned16 high = ROTR16(VH2_4(rb), VH2_4(src) & 0xf);
# OBSOLETE 	unsigned16 low  = ROTR16(VL2_4(rb), VL2_4(src) & 0xf);
# OBSOLETE 	WRITE32_QUEUE (ra, (high << 16) | low);
# OBSOLETE 
# OBSOLETE _LOGIC,10101,00,6.RA,6.RB,6.RC:LOGIC:short:iu,mu:ROT2H
# OBSOLETE "rot2h r<RA>, r<RB>, r<RC>"
# OBSOLETE 	do_rot2h(_SD, Ra, Rb, Rc);
# OBSOLETE _LOGIC,10101,10,6.RA,6.RB,_IMM6:LOGIC:short:iu,mu:ROT2H imm
# OBSOLETE "rot2h r<RA>, r<RB>, <imm>"
# OBSOLETE 	do_rot2h(_SD, Ra, Rb, immHL);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // SAT
# OBSOLETE 
# OBSOLETE void::function::do_sat:signed32 *ra, signed32 rb, signed32 src
# OBSOLETE 	int bits = LSMASKED32(src, 4, 0); /* 5 */
# OBSOLETE 	signed32 sat = LSMASK32(bits, 0) >> 2;
# OBSOLETE 	signed32 nsat = ~sat;
# OBSOLETE 	signed32 value;
# OBSOLETE 	if (bits != src)
# OBSOLETE 	  sim_io_eprintf (sd, "warning: 0x%lx:SAT bit overflow\n", (long) cia);
# OBSOLETE 	if (bits == 0)
# OBSOLETE 	  value = rb;
# OBSOLETE 	else if (rb >= sat)
# OBSOLETE 	  value = sat;
# OBSOLETE 	else if (rb <= nsat)
# OBSOLETE 	  value = nsat;
# OBSOLETE 	else
# OBSOLETE 	  value = rb;
# OBSOLETE 	WRITE32_QUEUE (ra, value);
# OBSOLETE 
# OBSOLETE _IALU2,01000,00,6.RA,6.RB,6.RC:IALU2:short:iu:SAT
# OBSOLETE "sat r<RA>, r<RB>, r<RC>"
# OBSOLETE 	do_sat(_SD, Ra, Rb, Rc);
# OBSOLETE _IALU2,01000,10,6.RA,6.RB,_IMM6:IALU2:short:iu:SAT imm
# OBSOLETE "sat r<RA>, r<RB>, <imm>"
# OBSOLETE 	do_sat(_SD, Ra, Rb, imm_5);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // SAT2H
# OBSOLETE 
# OBSOLETE void::function::do_sath:signed32 *ra, signed32 rb, signed32 src, int high, int updates_f4
# OBSOLETE 	int bits = LSMASKED32(src, 4, 0); /* 5 */
# OBSOLETE 	signed32 sat = LSMASK32(bits, 0) >> 2;
# OBSOLETE 	signed32 nsat = ~sat;
# OBSOLETE 	signed32 value;
# OBSOLETE 	if (bits != src)
# OBSOLETE 	  sim_io_eprintf (sd, "warning: 0x%lx:SAT bit overflow\n", (long) cia);
# OBSOLETE 	if (bits == 0)
# OBSOLETE 	  value = rb;
# OBSOLETE 	else if (rb >= sat)
# OBSOLETE 	  value = sat;
# OBSOLETE 	else if (rb <= nsat)
# OBSOLETE 	  value = nsat;
# OBSOLETE 	else
# OBSOLETE 	  value = rb;
# OBSOLETE 	if (high)
# OBSOLETE 	  WRITE32_QUEUE_MASK (ra, value << 16, 0xffff0000);
# OBSOLETE 	else
# OBSOLETE 	  WRITE32_QUEUE_MASK (ra, value, 0x0000ffff);
# OBSOLETE 	if (updates_f4)
# OBSOLETE 	  {
# OBSOLETE 	    /* if MU instruction was a MVTSYS (lkr), unqueue register writes now */
# OBSOLETE 	    if(STATE_CPU (sd, 0)->mvtsys_left_p)
# OBSOLETE 	      unqueue_writes (sd, STATE_CPU (sd, 0), cia);
# OBSOLETE 	    PSW_FLAG_SET_QUEUE(PSW_S_FLAG, PSW_FLAG_VAL(PSW_S_FLAG) ^ (value & 1));
# OBSOLETE 	  }
# OBSOLETE 
# OBSOLETE _IALU2,01001,00,6.RA,6.RB,6.RC:IALU2:short:iu:SAT2H
# OBSOLETE "sat2h r<RA>, r<RB>, r<RC>"
# OBSOLETE 	do_sath(_SD, Ra, RbH, RcH, 1, 0);
# OBSOLETE 	do_sath(_SD, Ra, RbL, RcL, 0, 0);
# OBSOLETE _IALU2,01001,10,6.RA,6.RB,_IMM6:IALU2:short:iu:SAT2H imm
# OBSOLETE "sat2h r<RA>, r<RB>, <imm>"
# OBSOLETE 	do_sath(_SD, Ra, RbH, imm_5, 1, 0);
# OBSOLETE 	do_sath(_SD, Ra, RbL, imm_5, 0, 0);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // SATHp
# OBSOLETE 
# OBSOLETE ::%s::p:int p
# OBSOLETE 	switch (p)
# OBSOLETE 	  {
# OBSOLETE 	  case 0: return "l";
# OBSOLETE 	  case 1: return "h";
# OBSOLETE 	  default: return "?";
# OBSOLETE 	  }
# OBSOLETE 
# OBSOLETE _IALU2,1110,p,00,6.RA,6.RB,6.RC:IALU2:short:iu:SATHP
# OBSOLETE "sath%s<p> r<RA>, r<RB>, r<RC>"
# OBSOLETE 	do_sath(_SD, Ra, Rb, Rc, p, 1);
# OBSOLETE _IALU2,1110,p,10,6.RA,6.RB,_IMM6:IALU2:short:iu:SATHP imm
# OBSOLETE "sath%s<p> r<RA>, r<RB>, <imm>"
# OBSOLETE 	do_sath(_SD, Ra, Rb, imm_5, p, 1);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // SATZ
# OBSOLETE 
# OBSOLETE void::function::do_satz:signed32 *ra, signed32 rb, signed32 src
# OBSOLETE 	if (rb < 0)
# OBSOLETE 	  WRITE32_QUEUE (ra, 0);
# OBSOLETE 	else
# OBSOLETE 	  do_sat (_SD, ra, rb, src);
# OBSOLETE 
# OBSOLETE _IALU2,01010,00,6.RA,6.RB,6.RC:IALU2:short:iu:SATZ
# OBSOLETE "satz r<RA>, r<RB>, r<RC>"
# OBSOLETE 	do_satz(_SD, Ra, Rb, Rc);
# OBSOLETE _IALU2,01010,10,6.RA,6.RB,_IMM6:IALU2:short:iu:SATZ imm
# OBSOLETE "satz r<RA>, r<RB>, <imm>"
# OBSOLETE 	do_satz(_SD, Ra, Rb, imm_5);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // SATZ2H
# OBSOLETE 
# OBSOLETE void::function::do_satzh:signed32 *ra, signed16 rb, signed32 src, int high
# OBSOLETE 	int bits = LSMASKED32(src, 3, 0); /*4*/
# OBSOLETE 	signed16 sat = LSMASK16(bits, 0) >> 2;
# OBSOLETE 	signed16 nsat = 0;
# OBSOLETE 	signed16 value;
# OBSOLETE 	if (bits != src)
# OBSOLETE 	  sim_io_eprintf (sd, "warning: 0x%lx:SATZ2H bit overflow\n", (long) cia);
# OBSOLETE 	if (bits == 0 && rb > sat)
# OBSOLETE 	  value = rb;
# OBSOLETE 	else if (rb > sat)
# OBSOLETE 	  value = sat;
# OBSOLETE 	else if (rb < nsat)
# OBSOLETE 	  value = nsat;
# OBSOLETE 	else
# OBSOLETE 	  value = rb;
# OBSOLETE 	if (high)
# OBSOLETE 	  WRITE32_QUEUE_MASK (ra, value << 16, 0xffff0000);
# OBSOLETE 	else
# OBSOLETE 	  WRITE32_QUEUE_MASK (ra, value, 0x0000ffff);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE _IALU2,01011,00,6.RA,6.RB,6.RC:IALU2:short:iu:SATZ2H
# OBSOLETE "satz2h r<RA>, r<RB>, r<RC>"
# OBSOLETE 	do_satzh(_SD, Ra, RbH, RcH, 1);
# OBSOLETE 	do_satzh(_SD, Ra, RbL, RcL, 0);
# OBSOLETE _IALU2,01011,10,6.RA,6.RB,_IMM6:IALU2:short:iu:SATZ2H imm
# OBSOLETE "satz2h r<RA>, r<RB>, <imm>"
# OBSOLETE 	do_satzh(_SD, Ra, RbH, imm, 1);
# OBSOLETE 	do_satzh(_SD, Ra, RbL, imm, 0);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // SRA
# OBSOLETE 
# OBSOLETE void::function::do_sra:unsigned32 *ra, unsigned32 rb, signed32 src
# OBSOLETE 	unsigned32 value;
# OBSOLETE 	while (src > 31) src -= 32;
# OBSOLETE 	while (src < -32) src += 32;
# OBSOLETE 	if (src >= 0)
# OBSOLETE 	  value = (signed32)rb >> src;
# OBSOLETE 	else if (src == -32)
# OBSOLETE 	  value = 0;
# OBSOLETE 	else
# OBSOLETE 	  value = rb << -src;
# OBSOLETE 	WRITE32_QUEUE (ra, value);
# OBSOLETE 
# OBSOLETE _LOGIC,10000,00,6.RA,6.RB,6.RC:LOGIC:short:iu,mu:SRA
# OBSOLETE "sra r<RA>, r<RB>, r<RC>"
# OBSOLETE 	do_sra(_SD, Ra, Rb, Rc);
# OBSOLETE _LOGIC,10000,10,6.RA,6.RB,_IMM6:LOGIC:short:iu,mu:SRA imm
# OBSOLETE "sra r<RA>, r<RB>, <imm>"
# OBSOLETE 	do_sra(_SD, Ra, Rb, imm);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // SRAHp
# OBSOLETE 
# OBSOLETE void::function::do_srah:unsigned32 *ra, unsigned32 rb, int src, int high
# OBSOLETE 	unsigned32 value;
# OBSOLETE 	while (src > 31) src -= 32;
# OBSOLETE 	while (src < -32) src += 32;
# OBSOLETE 	if (src >= 0)
# OBSOLETE 	  value = (signed32)rb >> src;
# OBSOLETE 	else if (src == -32)
# OBSOLETE 	  value = 0;
# OBSOLETE 	else
# OBSOLETE 	  value = rb << -src;
# OBSOLETE 	if (high)
# OBSOLETE 	  WRITE32_QUEUE_MASK (ra, value << 16, 0xffff0000);
# OBSOLETE 	else
# OBSOLETE 	  WRITE32_QUEUE_MASK (ra, value, 0x0000ffff);
# OBSOLETE 
# OBSOLETE _LOGIC,0010,p,00,6.RA,6.RB,6.RC:LOGIC:short:iu,mu:SRAHP
# OBSOLETE "srah%s<p> r<RA>, r<RB>, r<RC>"
# OBSOLETE 	do_srah(_SD, Ra, Rb, Rc, p);
# OBSOLETE _LOGIC,0010,p,10,6.RA,6.RB,_IMM6:LOGIC:short:iu,mu:SRAHP imm
# OBSOLETE "srah%s<p> r<RA>, r<RB>, <imm>"
# OBSOLETE 	do_srah(_SD, Ra, Rb, imm, p);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // SRA2H
# OBSOLETE 
# OBSOLETE _LOGIC,10001,00,6.RA,6.RB,6.RC:LOGIC:short:iu,mu:SRA2H
# OBSOLETE "sra2h r<RA>, r<RB>, r<RC>"
# OBSOLETE 	signed32 srcH = RcH;
# OBSOLETE 	signed32 srcL = RcL;
# OBSOLETE 	while (srcH > 15) srcH -= 16;
# OBSOLETE 	while (srcH < -16) srcH += 16;
# OBSOLETE 	while (srcL > 15) srcL -= 16;
# OBSOLETE 	while (srcL < -16) srcL += 16;
# OBSOLETE 	do_srah(_SD, Ra, RbH, srcH, 1);
# OBSOLETE 	do_srah(_SD, Ra, RbL, srcL, 0);
# OBSOLETE _LOGIC,10001,10,6.RA,6.RB,_IMM6:LOGIC:short:iu,mu:SRA2H imm
# OBSOLETE "sra2h r<RA>, r<RB>, <imm>"
# OBSOLETE 	signed32 src = imm;
# OBSOLETE 	while (src > 15) src -= 16;
# OBSOLETE 	while (src < -16) src += 16;
# OBSOLETE 	do_srah(_SD, Ra, RbH, src, 1);
# OBSOLETE 	do_srah(_SD, Ra, RbL, src, 0);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // SRC
# OBSOLETE 
# OBSOLETE void::function::do_src:unsigned32 *ra, unsigned32 rb, int src
# OBSOLETE 	unsigned32 value;
# OBSOLETE 	unsigned64 operand;
# OBSOLETE 	unsigned64 shifted;
# OBSOLETE 	while (src > 31) src -= 32;
# OBSOLETE 	while (src < -32) src += 32;
# OBSOLETE 	if (src >= 0)
# OBSOLETE 	  {
# OBSOLETE 	    operand = (INSERTED64(rb, 0, 31) | INSERTED64(*ra, 32, 63));
# OBSOLETE 	    shifted = operand >> src;
# OBSOLETE 	    value = EXTRACTED64(shifted, 32, 63);
# OBSOLETE 	  }
# OBSOLETE 	else
# OBSOLETE 	  {
# OBSOLETE 	    operand = (INSERTED64(*ra, 0, 31) | INSERTED64(rb, 32, 63));
# OBSOLETE 	    shifted = operand << -src;
# OBSOLETE 	    value = EXTRACTED64(shifted, 0, 31);
# OBSOLETE 	  }
# OBSOLETE 	WRITE32_QUEUE (ra, value);
# OBSOLETE 
# OBSOLETE _LOGIC,10110,00,6.RA,6.RB,6.RC:LOGIC:short:iu,mu:SRC
# OBSOLETE "src r<RA>, r<RB>, r<RC>"
# OBSOLETE 	do_src(_SD, Ra, Rb, Rc);
# OBSOLETE _LOGIC,10110,10,6.RA,6.RB,_IMM6:LOGIC:short:iu,mu:SRC imm
# OBSOLETE "src r<RA>, r<RB>, <imm>"
# OBSOLETE 	do_src(_SD, Ra, Rb, imm);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // SRL
# OBSOLETE 
# OBSOLETE void::function::do_srl:unsigned32 *ra, unsigned32 rb, int src
# OBSOLETE 	unsigned32 value;
# OBSOLETE 	while (src > 31) src -= 32;
# OBSOLETE 	while (src < -32) src += 32;
# OBSOLETE 	if (src >= 0)
# OBSOLETE 	  value = (unsigned32)rb >> src;
# OBSOLETE 	else if (src == -32)
# OBSOLETE 	  value = 0;
# OBSOLETE 	else
# OBSOLETE 	  value = (unsigned32)rb << -src;
# OBSOLETE 	WRITE32_QUEUE (ra, value);
# OBSOLETE 
# OBSOLETE _LOGIC,10010,00,6.RA,6.RB,6.RC:LOGIC:short:iu,mu:SRL
# OBSOLETE "srl r<RA>, r<RB>, r<RC>"
# OBSOLETE 	do_srl(_SD, Ra, Rb, Rc);
# OBSOLETE _LOGIC,10010,10,6.RA,6.RB,_IMM6:LOGIC:short:iu,mu:SRL imm
# OBSOLETE "srl r<RA>, r<RB>, <imm>"
# OBSOLETE 	do_srl(_SD, Ra, Rb, imm);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // SRLHp
# OBSOLETE 
# OBSOLETE void::function::do_srlh:unsigned32 *ra, unsigned32 rb, int src, int high
# OBSOLETE 	unsigned32 value;
# OBSOLETE 	while (src > 31) src -= 32;
# OBSOLETE 	while (src < -32) src += 32;
# OBSOLETE 	if (src >= 0)
# OBSOLETE 	  value = rb >> src;
# OBSOLETE 	else if (src == -32)
# OBSOLETE 	  value = 0;
# OBSOLETE 	else
# OBSOLETE 	  value = rb << -src;
# OBSOLETE 	if (high)
# OBSOLETE 	  WRITE32_QUEUE_MASK (ra, value << 16, 0xffff0000);
# OBSOLETE 	else
# OBSOLETE 	  WRITE32_QUEUE_MASK (ra, value, 0x0000ffff);
# OBSOLETE 
# OBSOLETE _LOGIC,0011,p,00,6.RA,6.RB,6.RC:LOGIC:short:iu,mu:SRLHP
# OBSOLETE "srlh%s<p> r<RA>, r<RB>, r<RC>"
# OBSOLETE 	do_srlh(_SD, Ra, Rb, Rc, p);
# OBSOLETE _LOGIC,0011,p,10,6.RA,6.RB,_IMM6:LOGIC:short:iu,mu:SRLHP imm
# OBSOLETE "srlh%s<p> r<RA>, r<RB>, <imm>"
# OBSOLETE 	do_srlh(_SD, Ra, Rb, imm, p);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // SRL2H
# OBSOLETE 
# OBSOLETE _LOGIC,10011,00,6.RA,6.RB,6.RC:LOGIC:short:iu,mu:SRL2H
# OBSOLETE "srl2h r<RA>, r<RB>, r<RC>"
# OBSOLETE 	signed32 srcH = RcH;
# OBSOLETE 	signed32 srcL = RcL;
# OBSOLETE 	while (srcH > 15) srcH -= 16;
# OBSOLETE 	while (srcH < -16) srcH += 16;
# OBSOLETE 	while (srcL > 15) srcL -= 16;
# OBSOLETE 	while (srcL < -16) srcL += 16;
# OBSOLETE 	do_srlh(_SD, Ra, RbHU, srcH, 1);
# OBSOLETE 	do_srlh(_SD, Ra, RbLU, srcL, 0);
# OBSOLETE _LOGIC,10011,10,6.RA,6.RB,_IMM6:LOGIC:short:iu,mu:SRL2H imm
# OBSOLETE "srl2h r<RA>, r<RB>, <imm>"
# OBSOLETE 	signed32 src = imm;
# OBSOLETE 	while (src > 15) src -= 16;
# OBSOLETE 	while (src < -16) src += 16;
# OBSOLETE 	do_srlh(_SD, Ra, RbHU, src, 1);
# OBSOLETE 	do_srlh(_SD, Ra, RbLU, src, 0);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // ST2H
# OBSOLETE 
# OBSOLETE void::function::get_even_reg:int *reg, unsigned32 *r0, const char *name
# OBSOLETE 	if (*reg & 1)
# OBSOLETE 	  sim_engine_abort (SD, CPU, cia,
# OBSOLETE 			    "0x%lx:%s odd register (r%d) used in multi-word store",
# OBSOLETE 			    (long) cia, name, *reg);
# OBSOLETE 	if (*reg == 0)
# OBSOLETE 	  *r0 = 0;
# OBSOLETE 	else
# OBSOLETE 	  *r0 = GPR[*reg];
# OBSOLETE 
# OBSOLETE void::function::do_st2h:int ra, unsigned32 rb, unsigned32 src
# OBSOLETE 	unsigned32 val_ra;
# OBSOLETE 	unsigned32 mem;
# OBSOLETE 	get_even_reg(_SD, &ra, &val_ra, "ST2H");
# OBSOLETE 	mem = INSERTED32(val_ra, 0, 15) |
# OBSOLETE 	      INSERTED32(GPR[ra + 1], 16, 31);
# OBSOLETE 	STORE(rb + src, 4, mem);
# OBSOLETE 
# OBSOLETE _IMEM,10011,XX,6.RA,6.RB,6.SRC_6:IMEM:short:mu:ST2H
# OBSOLETE "st2h r<RA>, @(r<RB>, <SRC_6>)":XX == 0
# OBSOLETE "st2h r<RA>, @(r<RB>%s<XX>, r<SRC_6>)"
# OBSOLETE 	do_st2h(_SD, RA, Rb, src);
# OBSOLETE 	do_incr(_SD, XX, &GPR[RB], 4);
# OBSOLETE _IMEM,10011,10,6.RA,6.RB,_IMM32:IMEM:long:mu:ST2H long
# OBSOLETE "st2h r<RA>, @(r<RB>, <imm>)"
# OBSOLETE 	do_st2h(_SD, RA, Rb, imm);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // ST2W
# OBSOLETE 
# OBSOLETE void::function::do_st2w:int ra, unsigned32 rb, unsigned32 src
# OBSOLETE 	unsigned32 val_ra;
# OBSOLETE 	unsigned64 mem;
# OBSOLETE 	get_even_reg(_SD, &ra, &val_ra, "ST2W");
# OBSOLETE 	mem = INSERTED64(val_ra, 0, 31) | INSERTED64(GPR[ra + 1], 32, 63);
# OBSOLETE 	STORE(rb + src, 8, mem);
# OBSOLETE 
# OBSOLETE _IMEM,10110,XX,6.RA,6.RB,6.SRC_6:IMEM:short:mu:ST2W
# OBSOLETE "st2w r<RA>, @(r<RB>, <SRC_6>)":XX == 0
# OBSOLETE "st2w r<RA>, @(r<RB>%s<XX>, r<SRC_6>)"
# OBSOLETE 	do_st2w(_SD, RA, Rb, src);
# OBSOLETE 	do_incr(_SD, XX, &GPR[RB], 8);
# OBSOLETE _IMEM,10110,10,6.RA,6.RB,_IMM32:IMEM:long:mu:ST2W long
# OBSOLETE "st2w r<RA>, @(r<RB>, <imm>)"
# OBSOLETE 	do_st2w(_SD, RA, Rb, imm);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // ST4HB
# OBSOLETE 
# OBSOLETE void::function::do_st4hb:int ra, unsigned32 rb, unsigned32 src
# OBSOLETE 	unsigned32 val_ra;
# OBSOLETE 	unsigned32 mem;
# OBSOLETE 	get_even_reg(_SD, &ra, &val_ra, "ST4HB");
# OBSOLETE 	mem = INSERTED32(EXTRACTED32(val_ra, 8, 15), 0, 7) |
# OBSOLETE 	      INSERTED32(EXTRACTED32(val_ra, 24, 31), 8, 15) |
# OBSOLETE 	      INSERTED32(EXTRACTED32(GPR[ra + 1], 8, 15), 16, 23) |
# OBSOLETE 	      INSERTED32(EXTRACTED32(GPR[ra + 1], 24, 31), 24, 31);
# OBSOLETE 	STORE(rb + src, 4, mem);
# OBSOLETE 
# OBSOLETE _IMEM,10101,XX,6.RA,6.RB,6.SRC_6:IMEM:short:mu:ST4HB
# OBSOLETE "st4hb r<RA>, @(r<RB>, <SRC_6>)":XX == 0
# OBSOLETE "st4hb r<RA>, @(r<RB>%s<XX>, r<SRC_6>)"
# OBSOLETE 	do_st4hb(_SD, RA, Rb, src);
# OBSOLETE 	do_incr(_SD, XX, &GPR[RB], 4);
# OBSOLETE _IMEM,10101,10,6.RA,6.RB,_IMM32:IMEM:long:mu:ST4HB long
# OBSOLETE "st4hb r<RA>, @(r<RB>, <imm>)"
# OBSOLETE 	do_st4hb(_SD, RA, Rb, imm);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // STB
# OBSOLETE 
# OBSOLETE void::function::do_stb:unsigned32 ra, unsigned32 rb, unsigned32 src
# OBSOLETE 	STORE(rb + src, 1, EXTRACTED32(ra, 24, 31));
# OBSOLETE 
# OBSOLETE _IMEM,10000,XX,6.RA,6.RB,6.SRC_6:IMEM:short:mu:STB
# OBSOLETE "stb r<RA>, @(r<RB>, <SRC_6>)":XX == 0
# OBSOLETE "stb r<RA>, @(r<RB>%s<XX>, r<SRC_6>)"
# OBSOLETE 	do_stb(_SD, val_Ra, Rb, src);
# OBSOLETE 	do_incr(_SD, XX, &GPR[RB], 1);
# OBSOLETE _IMEM,10000,10,6.RA,6.RB,_IMM32:IMEM:long:mu:STB long
# OBSOLETE "stb r<RA>, @(r<RB>, <imm>)"
# OBSOLETE 	do_stb(_SD, val_Ra, Rb, imm);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // STH
# OBSOLETE 
# OBSOLETE void::function::do_sth:unsigned32 ra, unsigned32 rb, unsigned32 src
# OBSOLETE 	STORE(rb + src, 2, EXTRACTED32(ra, 16, 31));
# OBSOLETE 
# OBSOLETE _IMEM,10010,XX,6.RA,6.RB,6.SRC_6:IMEM:short:mu:STH
# OBSOLETE "sth r<RA>, @(r<RB>, <SRC_6>)":XX == 0
# OBSOLETE "sth r<RA>, @(r<RB>%s<XX>, r<SRC_6>)"
# OBSOLETE 	do_sth(_SD, val_Ra, Rb, src);
# OBSOLETE 	do_incr(_SD, XX, &GPR[RB], 2);
# OBSOLETE _IMEM,10010,10,6.RA,6.RB,_IMM32:IMEM:long:mu:STH long
# OBSOLETE "sth r<RA>, @(r<RB>, <imm>)"
# OBSOLETE 	do_sth(_SD, val_Ra, Rb, imm);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // STHH
# OBSOLETE 
# OBSOLETE void::function::do_sthh:unsigned32 ra, unsigned32 rb, unsigned32 src
# OBSOLETE 	STORE(rb + src, 2, EXTRACTED32(ra, 0, 15));
# OBSOLETE 
# OBSOLETE _IMEM,10001,XX,6.RA,6.RB,6.SRC_6:IMEM:short:mu:STHH
# OBSOLETE "sthh r<RA>, @(r<RB>, <SRC_6>)":XX == 0
# OBSOLETE "sthh r<RA>, @(r<RB>%s<XX>, r<SRC_6>)"
# OBSOLETE 	do_sthh(_SD, val_Ra, Rb, src);
# OBSOLETE 	do_incr(_SD, XX, &GPR[RB], 2);
# OBSOLETE _IMEM,10001,10,6.RA,6.RB,_IMM32:IMEM:long:mu:STHH long
# OBSOLETE "sthh r<RA>, @(r<RB>, <imm>)"
# OBSOLETE 	do_sthh(_SD, val_Ra, Rb, imm);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // STW
# OBSOLETE 
# OBSOLETE void::function::do_stw:unsigned32 ra, unsigned32 rb, unsigned32 src
# OBSOLETE 	STORE(rb + src, 4, ra);
# OBSOLETE 
# OBSOLETE _IMEM,10100,XX,6.RA,6.RB,6.SRC_6:IMEM:short:mu:STW
# OBSOLETE "stw r<RA>, @(r<RB>, <SRC_6>)":XX == 0
# OBSOLETE "stw r<RA>, @(r<RB>%s<XX>, r<SRC_6>)"
# OBSOLETE 	do_stw(_SD, val_Ra, Rb, src);
# OBSOLETE 	do_incr(_SD, XX, &GPR[RB], 4);
# OBSOLETE _IMEM,10100,10,6.RA,6.RB,_IMM32:IMEM:long:mu:STW long
# OBSOLETE "stw r<RA>, @(r<RB>, <imm>)"
# OBSOLETE 	do_stw(_SD, val_Ra, Rb, imm);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // SUB
# OBSOLETE 
# OBSOLETE void::function::do_sub:unsigned32 *ra, unsigned32 rb, unsigned32 imm
# OBSOLETE 	ALU_BEGIN(rb);
# OBSOLETE 	ALU_SUBB(imm);
# OBSOLETE 	ALU_END(ra);
# OBSOLETE 
# OBSOLETE _IALU1,00010,00,6.RA,6.RB,6.RC:IALU1:short:iu,mu:SUB
# OBSOLETE "sub r<RA>, r<RB>, r<RC>"
# OBSOLETE 	do_sub (_SD, Ra, Rb, Rc);
# OBSOLETE _IALU1,00010,10,6.RA,6.RB,_IMM6:IALU1:short:iu,mu:SUB imm
# OBSOLETE "sub r<RA>, r<RB>, <imm>"
# OBSOLETE 	do_sub (_SD, Ra, Rb, imm);
# OBSOLETE _IALU1,00010,10,6.RA,6.RB,_IMM32:IALU1:long:iu,mu:SUB imm long
# OBSOLETE "sub r<RA>, r<RB>, <imm>"
# OBSOLETE 	do_sub (_SD, Ra, Rb, imm);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // SUB2H
# OBSOLETE 
# OBSOLETE void::function::do_sub2h:unsigned32 *ra, unsigned32 rb, unsigned32 imm
# OBSOLETE 	unsigned16 high = VH2_4(rb) - VH2_4(imm);
# OBSOLETE 	unsigned16 low  = VL2_4(rb) - VL2_4(imm);
# OBSOLETE 	WRITE32_QUEUE (ra, (high << 16) | low);
# OBSOLETE 
# OBSOLETE _IALU1,00011,00,6.RA,6.RB,6.RC:IALU1:short:iu,mu:SUB2H
# OBSOLETE "sub2h r<RA>, r<RB>, r<RC>"
# OBSOLETE 	do_sub2h (_SD, Ra, Rb, Rc);
# OBSOLETE _IALU1,00011,10,6.RA,6.RB,_IMM6:IALU1:short:iu,mu:SUB2H imm
# OBSOLETE "sub2h r<RA>, r<RB>, <imm>"
# OBSOLETE 	do_sub2h (_SD, Ra, Rb, immHL);
# OBSOLETE _IALU1,00011,10,6.RA,6.RB,_IMM32:IALU1:long:iu,mu:SUB2H imm long
# OBSOLETE "sub2h r<RA>, r<RB>, <imm>"
# OBSOLETE 	do_sub2h (_SD, Ra, Rb, imm);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // SUBB
# OBSOLETE 
# OBSOLETE void::function::do_subb:unsigned32 *ra, unsigned32 rb, unsigned32 imm
# OBSOLETE 	ALU_BEGIN(rb);
# OBSOLETE 	ALU_SUBB_B(imm, ALU_CARRY);
# OBSOLETE 	ALU_END(ra);
# OBSOLETE 	
# OBSOLETE _IALU1,00101,00,6.RA,6.RB,6.RC:IALU1:short:iu,mu:SUBB
# OBSOLETE "subb r<RA>, r<RB>, r<RC>"
# OBSOLETE 	do_subb (_SD, Ra, Rb, Rc);
# OBSOLETE _IALU1,00101,10,6.RA,6.RB,_IMM6:IALU1:short:iu,mu:SUBB imm
# OBSOLETE "subb r<RA>, r<RB>, <imm>"
# OBSOLETE 	do_subb (_SD, Ra, Rb, imm);
# OBSOLETE _IALU1,00101,10,6.RA,6.RB,_IMM32:IALU1:long:iu,mu:SUBB imm long
# OBSOLETE "subb r<RA>, r<RB>, <imm>"
# OBSOLETE 	do_subb (_SD, Ra, Rb, imm);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // SUBHppp
# OBSOLETE 
# OBSOLETE void::function::do_subh_ppp:int ppp, unsigned32 *ra, unsigned32 rb, unsigned32 src
# OBSOLETE 	switch (ppp) {
# OBSOLETE 	case 0x0: /* LLL */
# OBSOLETE 	  {
# OBSOLETE 	  ALU16_BEGIN(VL2_4(rb));
# OBSOLETE 	  ALU16_SUBB(VL2_4(src));
# OBSOLETE 	  ALU16_END(ra, 0);
# OBSOLETE 	  }
# OBSOLETE 	  break;
# OBSOLETE 	case 0x1: /* LLH */
# OBSOLETE 	  {
# OBSOLETE 	  ALU16_BEGIN(VL2_4(rb));
# OBSOLETE 	  ALU16_SUBB(VH2_4(src));
# OBSOLETE 	  ALU16_END(ra, 0);
# OBSOLETE 	  }
# OBSOLETE 	  break;
# OBSOLETE 	case 0x2: /* LHL */
# OBSOLETE 	  {
# OBSOLETE 	  ALU16_BEGIN(VH2_4(rb));
# OBSOLETE 	  ALU16_SUBB(VL2_4(src));
# OBSOLETE 	  ALU16_END(ra, 0);
# OBSOLETE 	  }
# OBSOLETE 	  break;
# OBSOLETE 	case 0x3: /* LHH */
# OBSOLETE 	  {
# OBSOLETE 	  ALU16_BEGIN(VH2_4(rb));
# OBSOLETE 	  ALU16_SUBB(VH2_4(src));
# OBSOLETE 	  ALU16_END(ra, 0);
# OBSOLETE 	  }
# OBSOLETE 	  break;
# OBSOLETE 	case 0x4: /* HLL */
# OBSOLETE 	  {
# OBSOLETE 	  ALU16_BEGIN(VL2_4(rb));
# OBSOLETE 	  ALU16_SUBB(VL2_4(src));
# OBSOLETE 	  ALU16_END(ra, 1);
# OBSOLETE 	  }
# OBSOLETE 	  break;
# OBSOLETE 	case 0x5: /* HLH */
# OBSOLETE 	  {
# OBSOLETE 	  ALU16_BEGIN(VL2_4(rb));
# OBSOLETE 	  ALU16_SUBB(VH2_4(src));
# OBSOLETE 	  ALU16_END(ra, 1);
# OBSOLETE 	  }
# OBSOLETE 	  break;
# OBSOLETE 	case 0x6: /* HHL */
# OBSOLETE 	  {
# OBSOLETE 	  ALU16_BEGIN(VH2_4(rb));
# OBSOLETE 	  ALU16_SUBB(VL2_4(src));
# OBSOLETE 	  ALU16_END(ra, 1);
# OBSOLETE 	  }
# OBSOLETE 	  break;
# OBSOLETE 	case 0x7: /* HHH */
# OBSOLETE 	  {
# OBSOLETE 	  ALU16_BEGIN(VH2_4(rb));
# OBSOLETE 	  ALU16_SUBB(VH2_4(src));
# OBSOLETE 	  ALU16_END(ra, 1);
# OBSOLETE 	  }
# OBSOLETE 	  break;
# OBSOLETE 	default:
# OBSOLETE 	  sim_engine_abort (SD, CPU, cia, "do_subh_ppp - internal error - bad switch");
# OBSOLETE 	}
# OBSOLETE 
# OBSOLETE _IALU1,11,ppp,00,6.RA,6.RB,6.RC:IALU1:short:iu,mu:SUBHppp
# OBSOLETE "subh%s<ppp> r<RA>, r<RB>, r<RC>"
# OBSOLETE 	do_subh_ppp(_SD, ppp, Ra, Rb, Rc);
# OBSOLETE _IALU1,11,ppp,10,6.RA,6.RB,_IMM6:IALU1:short:iu,mu:SUBHppp imm
# OBSOLETE "subh%s<ppp> r<RA>, r<RB>, <imm>"
# OBSOLETE 	do_subh_ppp(_SD, ppp, Ra, Rb, immHL);
# OBSOLETE _IALU1,11,ppp,10,6.RA,6.RB,_IMM32:IALU1:long:iu,mu:SUBHppp imm long
# OBSOLETE "subh%s<ppp> r<RA>, r<RB>, <imm>"
# OBSOLETE 	do_subh_ppp(_SD, ppp, Ra, Rb, imm);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // TRAP
# OBSOLETE 
# OBSOLETE address_word::function::do_trap:address_word trap_vector, address_word nia
# OBSOLETE 	/* Steal trap 31 for doing system calls */
# OBSOLETE 	/* System calls are defined in libgloss/d30v/syscall.h.  */
# OBSOLETE 	if (trap_vector == EIT_VB + 0x20 + (31 << 3))
# OBSOLETE 	  {
# OBSOLETE 	    enum { PARM1 = 2, PARM2, PARM3, PARM4, FUNC };
# OBSOLETE 	    if (GPR[FUNC] == 1)		/* exit */
# OBSOLETE 	      {
# OBSOLETE 	        sim_engine_halt (sd, STATE_CPU (sd, 0), NULL, cia, sim_exited,
# OBSOLETE 		  	         GPR[PARM1]);
# OBSOLETE 	        return -1; /* dummy */
# OBSOLETE 	      }
# OBSOLETE 	    else
# OBSOLETE 	      {
# OBSOLETE 		CB_SYSCALL syscall;
# OBSOLETE 
# OBSOLETE 		CB_SYSCALL_INIT (&syscall);
# OBSOLETE 		syscall.arg1 = GPR[PARM1];
# OBSOLETE 		syscall.arg2 = GPR[PARM2];
# OBSOLETE 		syscall.arg3 = GPR[PARM3];
# OBSOLETE 		syscall.arg4 = GPR[PARM4];
# OBSOLETE 		syscall.func = GPR[FUNC];
# OBSOLETE 		syscall.p1 = (PTR) SD;
# OBSOLETE 		syscall.read_mem = d30v_read_mem;
# OBSOLETE 		syscall.write_mem = d30v_write_mem;
# OBSOLETE 
# OBSOLETE 		WRITE32_QUEUE (&GPR[PARM1],
# OBSOLETE 			       ((cb_syscall (STATE_CALLBACK (SD), &syscall)
# OBSOLETE 				 == CB_RC_OK)
# OBSOLETE 				? syscall.result
# OBSOLETE 				: -syscall.errcode));
# OBSOLETE 		return nia;
# OBSOLETE 	      }
# OBSOLETE 	  }
# OBSOLETE 	else if (TRACE_TRAP_P)
# OBSOLETE 	  {
# OBSOLETE 	    int reg, i;
# OBSOLETE 	    sim_io_eprintf (sd, "\nTrap %ld:\n", (long) ((trap_vector - (EIT_VB + 0x20)) >> 3));
# OBSOLETE 	    for (reg = 0; reg < NR_GENERAL_PURPOSE_REGISTERS; reg += 8)
# OBSOLETE 	      {
# OBSOLETE 		sim_io_eprintf (sd, "r%.2d  - r%.2d: ", reg, reg+7);
# OBSOLETE 		for (i = 0; i < 8; i++)
# OBSOLETE 		  sim_io_eprintf (sd, " 0x%.8lx", (long) GPR[reg+i]);
# OBSOLETE 		sim_io_eprintf (sd, "\n");
# OBSOLETE 	      }
# OBSOLETE 
# OBSOLETE 	    for (reg = 0; reg < 16; reg += 8)
# OBSOLETE 	      {
# OBSOLETE 		sim_io_eprintf (sd, "cr%.2d - cr%.2d:", reg, reg+7);
# OBSOLETE 		for (i = 0; i < 8; i++)
# OBSOLETE 		  sim_io_eprintf (sd, " 0x%.8lx", (long) CREG[reg+i]);
# OBSOLETE 		sim_io_eprintf (sd, "\n");
# OBSOLETE 	      }
# OBSOLETE 
# OBSOLETE 	    sim_io_eprintf (sd, "a0   - a1:  ");
# OBSOLETE 	    for (reg = 0; reg < NR_ACCUMULATORS; reg++)
# OBSOLETE 	      sim_io_eprintf (sd, " 0x%.8lx 0x%.8lx",
# OBSOLETE 			      (long)EXTRACTED64(ACC[reg], 0, 31),
# OBSOLETE 			      (long)EXTRACTED64(ACC[reg], 32, 63));
# OBSOLETE 	    sim_io_eprintf (sd, "\n");
# OBSOLETE 
# OBSOLETE 	    sim_io_eprintf (sd, "f0   - f7:  ");
# OBSOLETE 	    sim_io_eprintf (sd, "     (f0) %d", (int) PSW_VAL(PSW_F0));
# OBSOLETE 	    sim_io_eprintf (sd, "     (f1) %d", (int) PSW_VAL(PSW_F1));
# OBSOLETE 	    sim_io_eprintf (sd, "     (f2) %d", (int) PSW_VAL(PSW_F2));
# OBSOLETE 	    sim_io_eprintf (sd, "     (f3) %d", (int) PSW_VAL(PSW_F3));
# OBSOLETE 	    sim_io_eprintf (sd, "      (s) %d", (int) PSW_VAL(PSW_S));
# OBSOLETE 	    sim_io_eprintf (sd, "      (v) %d", (int) PSW_VAL(PSW_V));
# OBSOLETE 	    sim_io_eprintf (sd, "     (va) %d", (int) PSW_VAL(PSW_VA));
# OBSOLETE 	    sim_io_eprintf (sd, "      (c) %d\n", (int) PSW_VAL(PSW_C));
# OBSOLETE 
# OBSOLETE 	    sim_io_eprintf (sd, "pswh:       ");
# OBSOLETE 	    sim_io_eprintf (sd, "     (sm) %d", (int) PSW_VAL(PSW_SM));
# OBSOLETE 	    sim_io_eprintf (sd, "     (ea) %d", (int) PSW_VAL(PSW_EA));
# OBSOLETE 	    sim_io_eprintf (sd, "     (ie) %d", (int) PSW_VAL(PSW_IE));
# OBSOLETE 	    sim_io_eprintf (sd, "     (rp) %d", (int) PSW_VAL(PSW_RP));
# OBSOLETE 	    sim_io_eprintf (sd, "     (md) %d", (int) PSW_VAL(PSW_MD));
# OBSOLETE 
# OBSOLETE 	    if (PSW_VAL(PSW_DB))
# OBSOLETE 	      sim_io_eprintf (sd, "     (db) %d", (int) PSW_VAL(PSW_DB));
# OBSOLETE 
# OBSOLETE 	    if (PSW_VAL(PSW_DS))
# OBSOLETE 	      sim_io_eprintf (sd, "     (ds) %d", (int) PSW_VAL(PSW_DS));
# OBSOLETE 
# OBSOLETE 	    sim_io_eprintf (sd, "\n");
# OBSOLETE 	    return nia;
# OBSOLETE 	  }
# OBSOLETE 	else
# OBSOLETE 	  {
# OBSOLETE 	    if(PSW_VAL(PSW_RP) && RPT_E == cia)
# OBSOLETE 	      {
# OBSOLETE 		WRITE32_QUEUE (&bPC, RPT_S);
# OBSOLETE 		if (RPT_C == 0)
# OBSOLETE 		  PSW_SET (PSW_RP, 0);
# OBSOLETE 	      }
# OBSOLETE 	    else
# OBSOLETE 	      WRITE32_QUEUE (&bPC, cia + 8);
# OBSOLETE 	    DID_TRAP = 1;
# OBSOLETE 	    return trap_vector;
# OBSOLETE 	  }
# OBSOLETE 
# OBSOLETE _BRA,01001,00,6.**,6.**,6.RC:BRA:short:mu:TRAP
# OBSOLETE "trap r<RC>"
# OBSOLETE 	nia = do_trap (_SD, EIT_VB + 0x20 + MASKED32(Rc, 24, 28), nia);
# OBSOLETE _BRA,01001,10,6.**,6.**,_IMM6:BRA:short:mu:TRAP imm
# OBSOLETE "trap <imm>"
# OBSOLETE 	nia = do_trap (_SD, EIT_VB + 0x20 + (imm_5 << 3), nia);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // XOR
# OBSOLETE 
# OBSOLETE _LOGIC,11011,00,6.RA,6.RB,6.RC:LOGIC:short:iu,mu:XOR
# OBSOLETE "xor r<RA>, r<RB>, r<RC>"
# OBSOLETE 	WRITE32_QUEUE (Ra, Rb ^ Rc);
# OBSOLETE _LOGIC,11011,10,6.RA,6.RB,_IMM6:LOGIC:short:iu,mu:XOR imm
# OBSOLETE "xor r<RA>, r<RB>, <imm>"
# OBSOLETE 	WRITE32_QUEUE (Ra, Rb ^ imm);
# OBSOLETE _LOGIC,11011,10,6.RA,6.RB,_IMM32:LOGIC:long:iu,mu:XOR imm long
# OBSOLETE "xor r<RA>, r<RB>, <imm>"
# OBSOLETE 	WRITE32_QUEUE (Ra, Rb ^ imm);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // XORFG
# OBSOLETE 
# OBSOLETE _LOGIC,01011,00,***,3.FA,***,3.FB,***,3.FC:LOGIC:short:iu,mu:XORFG
# OBSOLETE "xorfg f<FA>, f<FB>, f<FC>"
# OBSOLETE 	PSW_FLAG_SET_QUEUE(FA, PSW_FLAG_VAL(FB) ^ PSW_FLAG_VAL(FC));
# OBSOLETE _LOGIC,01011,10,***,3.FA,***,3.FB,_IMM6:LOGIC:short:iu,mu:XORFG imm
# OBSOLETE "xorfg f<FA>, f<FB>, <imm_6>"
# OBSOLETE 	PSW_FLAG_SET_QUEUE(FA, PSW_FLAG_VAL(FB) ^ (imm_6 & 1));

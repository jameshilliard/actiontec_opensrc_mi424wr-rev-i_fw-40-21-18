/*
 * SPCA504 chip based cameras initialization data
 *
 */
#ifndef SPCA504_INIT_H
#define SPCA504_INIT_H

#define IGN(x) /* nothing */
/* Frame packet header offsets for the spca504 (PC-CAM 600) */
#define SPCA504_PCCAM600_OFFSET_SNAPSHOT 3
#define SPCA504_PCCAM600_OFFSET_COMPRESS 4
#define SPCA504_PCCAM600_OFFSET_MODE	 5
#define SPCA504_PCCAM600_OFFSET_DATA	 14
static void spca504_acknowledged_command(struct usb_spca50x *spca50x, 
                                         __u16               reg,
                                         __u16               idx,
                                         __u16               val);
					 
static void spca504A_acknowledged_command(struct usb_spca50x *spca50x, 
				 __u16 reg,
				 __u16 idx,
				 __u16 val,
				 __u8 stat,
				 __u8 count);
static void spca504_pccam600_initialize(struct usb_spca50x *spca50x);

static void spca504_initialize(struct usb_spca50x *spca50x);
static void spca504_wait_status(struct usb_spca50x *spca50x);
/*********************** Specific spca504b  *********************************/

static void spca504B_init(struct usb_spca50x *spca50x);
static void spca504B_start(struct usb_spca50x *spca50x);
static void spca504B_stop (struct usb_spca50x *spca50x);
static void spca504B_SetSizeType(struct usb_spca50x *spca50x,
			 __u16 extSize,
			 __u16 extType);
/*
 * Initialisation data: this is the first set-up data written to the
 * device (before the open data).
 */
#if 0
static __u16 spca504_init_data[][3]=
{
  /*  line   URB    req,  value, index */
  { 0,0,0 }
};
#endif

/* Initialisation data for the Creative PC-CAM 600 */
static __u16 spca504_pccam600_init_data[][3] =
{
//	{0xa0, 0x0000, 0x0503}, /* capture mode */
	{0x00, 0x0000, 0x2000},
	{0x00, 0x0013, 0x2301},
	{0x00, 0x0003, 0x2000},
	{0x00, 0x0001, 0x21ac},
	{0x00, 0x0001, 0x21a6},
	{0x00, 0x0000, 0x21a7}, /* brightness */
	{0x00, 0x0020, 0x21a8}, /* contrast */
	{0x00, 0x0001, 0x21ac}, /* sat/hue */
	{0x00, 0x0000, 0x21ad}, /* hue */
	{0x00, 0x001a, 0x21ae}, /* saturation */
	{0x00, 0x0002, 0x21a3}, /* gamma */
#if 0	
	{0xb0, 0x0000, 0x0000},	/* reset auto exposure */
	{0x0c, 0x0000, 0x0000}, /* reset auto whiteness */
	{0x0c, 0x0004, 0x0000}, /* enable auto whiteness */ 
	{0x30, 0x020f, 0x0001}, /* exposure compensation */
	{0x30, 0x01f7, 0x0002}, /* whiteness balance */
#endif
	{0x30, 0x0154, 0x0008},
	{0x30, 0x0004, 0x0006},
	{0x30, 0x0258, 0x0009},
	{0x30, 0x0004, 0x0000},
	{0x30, 0x0093, 0x0004},
	{0x30, 0x0066, 0x0005},
	{0x00, 0x0000, 0x2000},
	{0x00, 0x0013, 0x2301},
	{0x00, 0x0003, 0x2000},
	{0x00, 0x0013, 0x2301},
	{0x00, 0x0003, 0x2000},

	{0,0,0}
};

/* Creative PC-CAM 600 specific open data, sent before using the
 * generic initialisation data from spca504_open_data.
 */
static __u16 spca504_pccam600_open_data[][3] =
{
	{0x00, 0x0001, 0x2501},
	{0x20, 0x0500, 0x0001}, /* snapshot mode */
	{0x00, 0x0003, 0x2880},
	{0x00, 0x0001, 0x2881},

	{0,0,0}
};
/* Initialisation data for the logitech clicksmart 420 */
static __u16 spca504A_clicksmart420_init_data[][3] =
{
//	{0xa0, 0x0000, 0x0503}, /* capture mode */
	{0x00, 0x0000, 0x2000},
	{0x00, 0x0013, 0x2301},
	{0x00, 0x0003, 0x2000},
	{0x00, 0x0001, 0x21ac},
	{0x00, 0x0001, 0x21a6},
	{0x00, 0x0000, 0x21a7}, /* brightness */
	{0x00, 0x0020, 0x21a8}, /* contrast */
	{0x00, 0x0001, 0x21ac}, /* sat/hue */
	{0x00, 0x0000, 0x21ad}, /* hue */
	{0x00, 0x001a, 0x21ae}, /* saturation */
	{0x00, 0x0002, 0x21a3}, /* gamma */
#if 1
	{0x30, 0x0004, 0x000a},
	{0xb0, 0x0001, 0x0000},
#endif

#if 0	
	{0xb0, 0x0000, 0x0000},	/* reset auto exposure */
	{0x0c, 0x0000, 0x0000}, /* reset auto whiteness */
	{0x0c, 0x0004, 0x0000}, /* enable auto whiteness */ 
	{0x30, 0x020f, 0x0001}, /* exposure compensation */
	{0x30, 0x01f7, 0x0002}, /* whiteness balance */
#endif

#if 1
	{0x0a1, 0x0080, 0x0001},
	{0x30, 0x0049, 0x0000},
	{0x30, 0x0060, 0x0005},
	{0x0c, 0x0004, 0x0000},
	{0x00, 0x0000, 0x0000},
	{0x00, 0x0000, 0x2000},
	{0x00, 0x0013, 0x2301},
	{0x00, 0x0003, 0x2000},
	{0x00, 0x0000, 0x2000},
#endif

#if 0	
	{0x30, 0x0154, 0x0008},
	{0x30, 0x0004, 0x0006},
	{0x30, 0x0258, 0x0009},
	{0x30, 0x0004, 0x0000},
	{0x30, 0x0093, 0x0004},
	{0x30, 0x0066, 0x0005},
	{0x00, 0x0000, 0x2000},
	{0x00, 0x0013, 0x2301},
	{0x00, 0x0003, 0x2000},
	{0x00, 0x0013, 0x2301},
	{0x00, 0x0003, 0x2000},
#endif

	{0,0,0}
};

/* clicksmart 420 open data ? */
static __u16 spca504A_clicksmart420_open_data[][3] =
{
	{0x00, 0x0001, 0x2501},
	{0x20, 0x0502, 0x0000},
	{0x06, 0x0000, 0x0000},
	{0x00, 0x0004, 0x2880},
	{0x00, 0x0001, 0x2881},

	{0x00, 0x0006, 0x2800},
	{0x00, 0x0004, 0x2801},
	{0x00, 0x0004, 0x2802},
	{0x00, 0x0006, 0x2803},
	{0x00, 0x000a, 0x2804},
	{0x00, 0x0010, 0x2805},
	{0x00, 0x0014, 0x2806},
	{0x00, 0x0018, 0x2807},
	{0x00, 0x0005, 0x2808},
	{0x00, 0x0005, 0x2809},
	{0x00, 0x0006, 0x280a},
	{0x00, 0x0008, 0x280b},
	{0x00, 0x000a, 0x280c},
	{0x00, 0x0017, 0x280d},
	{0x00, 0x0018, 0x280e},
	{0x00, 0x0016, 0x280f},

	{0x00, 0x0006, 0x2810},
	{0x00, 0x0005, 0x2811},
	{0x00, 0x0006, 0x2812},
	{0x00, 0x000a, 0x2813},
	{0x00, 0x0010, 0x2814},
	{0x00, 0x0017, 0x2815},
	{0x00, 0x001c, 0x2816},
	{0x00, 0x0016, 0x2817},
	{0x00, 0x0006, 0x2818},
	{0x00, 0x0007, 0x2819},
	{0x00, 0x0009, 0x281a},
	{0x00, 0x000c, 0x281b},
	{0x00, 0x0014, 0x281c},
	{0x00, 0x0023, 0x281d},
	{0x00, 0x0020, 0x281e},
	{0x00, 0x0019, 0x281f},

	{0x00, 0x0007, 0x2820},
	{0x00, 0x0009, 0x2821},
	{0x00, 0x000f, 0x2822},
	{0x00, 0x0016, 0x2823},
	{0x00, 0x001b, 0x2824},
	{0x00, 0x002c, 0x2825},
	{0x00, 0x0029, 0x2826},
	{0x00, 0x001f, 0x2827},
	{0x00, 0x000a, 0x2828},
	{0x00, 0x000e, 0x2829},
	{0x00, 0x0016, 0x282a},
	{0x00, 0x001a, 0x282b},
	{0x00, 0x0020, 0x282c},
	{0x00, 0x002a, 0x282d},
	{0x00, 0x002d, 0x282e},
	{0x00, 0x0025, 0x282f},

	{0x00, 0x0014, 0x2830},
	{0x00, 0x001a, 0x2831},
	{0x00, 0x001f, 0x2832},
	{0x00, 0x0023, 0x2833},
	{0x00, 0x0029, 0x2834},
	{0x00, 0x0030, 0x2835},
	{0x00, 0x0030, 0x2836},
	{0x00, 0x0028, 0x2837},
	{0x00, 0x001d, 0x2838},
	{0x00, 0x0025, 0x2839},
	{0x00, 0x0026, 0x283a},
	{0x00, 0x0027, 0x283b},
	{0x00, 0x002d, 0x283c},
	{0x00, 0x0028, 0x283d},
	{0x00, 0x0029, 0x283e},
	{0x00, 0x0028, 0x283f},

	{0x00, 0x0007, 0x2840},
	{0x00, 0x0007, 0x2841},
	{0x00, 0x000a, 0x2842},
	{0x00, 0x0013, 0x2843},
	{0x00, 0x0028, 0x2844},
	{0x00, 0x0028, 0x2845},
	{0x00, 0x0028, 0x2846},
	{0x00, 0x0028, 0x2847},
	{0x00, 0x0007, 0x2848},
	{0x00, 0x0008, 0x2849},
	{0x00, 0x000a, 0x284a},
	{0x00, 0x001a, 0x284b},
	{0x00, 0x0028, 0x284c},
	{0x00, 0x0028, 0x284d},
	{0x00, 0x0028, 0x284e},
	{0x00, 0x0028, 0x284f},

	{0x00, 0x000a, 0x2850},
	{0x00, 0x000a, 0x2851},
	{0x00, 0x0016, 0x2852},
	{0x00, 0x0028, 0x2853},
	{0x00, 0x0028, 0x2854},
	{0x00, 0x0028, 0x2855},
	{0x00, 0x0028, 0x2856},
	{0x00, 0x0028, 0x2857},
	{0x00, 0x0013, 0x2858},
	{0x00, 0x001a, 0x2859},
	{0x00, 0x0028, 0x285a},
	{0x00, 0x0028, 0x285b},
	{0x00, 0x0028, 0x285c},
	{0x00, 0x0028, 0x285d},
	{0x00, 0x0028, 0x285e},
	{0x00, 0x0028, 0x285f},

	{0x00, 0x0028, 0x2860},
	{0x00, 0x0028, 0x2861},
	{0x00, 0x0028, 0x2862},
	{0x00, 0x0028, 0x2863},
	{0x00, 0x0028, 0x2864},
	{0x00, 0x0028, 0x2865},
	{0x00, 0x0028, 0x2866},
	{0x00, 0x0028, 0x2867},
	{0x00, 0x0028, 0x2868},
	{0x00, 0x0028, 0x2869},
	{0x00, 0x0028, 0x286a},
	{0x00, 0x0028, 0x286b},
	{0x00, 0x0028, 0x286c},
	{0x00, 0x0028, 0x286d},
	{0x00, 0x0028, 0x286e},
	{0x00, 0x0028, 0x286f},

	{0x00, 0x0028, 0x2870},
	{0x00, 0x0028, 0x2871},
	{0x00, 0x0028, 0x2872},
	{0x00, 0x0028, 0x2873},
	{0x00, 0x0028, 0x2874},
	{0x00, 0x0028, 0x2875},
	{0x00, 0x0028, 0x2876},
	{0x00, 0x0028, 0x2877},
	{0x00, 0x0028, 0x2878},
	{0x00, 0x0028, 0x2879},
	{0x00, 0x0028, 0x287a},
	{0x00, 0x0028, 0x287b},
	{0x00, 0x0028, 0x287c},
	{0x00, 0x0028, 0x287d},
	{0x00, 0x0028, 0x287e},
	{0x00, 0x0028, 0x287f},

	{0xa0, 0x0000, 0x0503},

	{0,0,0}
};


static void spca504_acknowledged_command(struct usb_spca50x *spca50x, 
				 __u16 reg,
				 __u16 idx,
				 __u16 val) 
{ 
	__u8 notdone = 0;

	spca50x_reg_write(spca50x->dev,reg,idx,val);
	notdone=spca50x_reg_read(spca50x->dev, 0x01, 0x0001, 1);
	spca50x_reg_write(spca50x->dev,reg,idx,val);

	PDEBUG(5,"before wait 0x%x",notdone);

	wait_ms(200);
	notdone=spca50x_reg_read(spca50x->dev, 0x01, 0x0001, 1);
	PDEBUG(5,"after wait 0x%x",notdone);
	
	return;
}

static void spca504A_acknowledged_command(struct usb_spca50x *spca50x, 
				 __u16 reg,
				 __u16 idx,
				 __u16 val,
				 __u8 stat,
				 __u8 count) 
{ 
	__u8  status ;
	__u8  endcode;
	

	spca50x_reg_write(spca50x->dev,reg,idx,val);
	status=spca50x_reg_read(spca50x->dev, 0x01, 0x0001, 1);
	endcode = stat ;
	PDEBUG(5,"Status 0x%x Need 0x%x",status, stat);
	if (count) {
		while (1){
			wait_ms(10);
			/* gsmart mini2 write a each wait setting 1 ms is enought*/
			//spca50x_reg_write(spca50x->dev,reg,idx,val);
			status=spca50x_reg_read(spca50x->dev, 0x01, 0x0001, 1);
			if (status == endcode) {
				 PDEBUG(5,"status 0x%x after wait 0x%x",status,count);
				break;
			}
			count++;
			if(count > 200) break;
		
		}
	}
	return;
}

static void spca504_pccam600_initialize(struct usb_spca50x *spca50x)
{
	int enable;
	if (spca50x->desc == LogitechClickSmart420) {
	spca50x_write_vector(spca50x, spca504A_clicksmart420_init_data);
	} else {
	spca50x_write_vector(spca50x, spca504_pccam600_init_data);
	}
	enable = (autoexpo ? 0x4 : 0x1);
	spca50x_reg_write(spca50x->dev, 0x0c, 0x0000, enable); // auto exposure
	spca50x_reg_write(spca50x->dev, 0xb0, 0x0000, enable); // auto whiteness
		
	/* set default exposure compensation and whiteness balance */
	spca50x_reg_write(spca50x->dev, 0x30, 0x0001, 800); // ~ 20 fps
	spca50x_reg_write(spca50x->dev, 0x30, 0x0002, 1600);
}


/* version based on the snoops of gsmart mini3 */
static void spca504_initialize(struct usb_spca50x *spca50x)
{
	__u8 i;
	__u8 info[6];

		
		if (spca50x->desc == AiptekMiniPenCam13){
		for (i=0; i<6; i++)
		{
			info[i]=spca50x_reg_read_with_value(spca50x->dev,
			                                    0x20, i, 0x0000, 1);
		}
		PDEBUG(0, "Read info: %d %d %d %d %d %d . Should be 1,0,2,2,0,0\n",
		       info[0], info[1], info[2], info[3], info[4], info[5]);
					/* spca504a aiptek */
			// Set AE AWB Banding Type 3-> 50Hz 2-> 60Hz 	       
			spca504A_acknowledged_command(spca50x, 0x24, 8, 3,0x9e,1);
			// Twice sequencial need status 0xff->0x9e->0x9d 
			spca504A_acknowledged_command(spca50x, 0x24, 8, 3,0x9e,0);

			spca504A_acknowledged_command(spca50x, 0x24, 0, 0,0x9d,1);
		} else {
			spca504_acknowledged_command(spca50x, 0x24, 8, 3);
			for (i=0; i<6; i++)
			{
			info[i]=spca50x_reg_read_with_value(spca50x->dev,
			                                    0x20, i, 0x0000, 1);
			}
			PDEBUG(0, "Read info: %d %d %d %d %d %d . Should be 1,0,2,2,0,0\n",
		       info[0], info[1], info[2], info[3], info[4], info[5]);
			spca504_acknowledged_command(spca50x, 0x24, 8, 3);

			spca504_acknowledged_command(spca50x, 0x24, 0, 0);
		}
		
		
		spca50x_reg_write(spca50x->dev, 0x0, 0x270c, 0x5); // L92 sno1t.txt 

		spca50x_reg_write(spca50x->dev, 0x0, 0x2310, 0x5);

		spca50x_reg_write(spca50x->dev, 0x0, 0x21a7, 0x0000); /* brightness */
		spca50x_reg_write(spca50x->dev, 0x0, 0x21a8, 0x0020); /* contrast */
		spca50x_reg_write(spca50x->dev, 0x0, 0x21ad, 0x0000); /* hue */
		spca50x_reg_write(spca50x->dev, 0x0, 0x21ac, 0x0001); /* sat/hue */
		spca50x_reg_write(spca50x->dev, 0x0, 0x21ae, 0x0020); /* saturation */
		spca50x_reg_write(spca50x->dev, 0x0, 0x21a3, 0x0000); /* gamma */
	
}

static void spca504_wait_status(struct usb_spca50x *spca50x)
{
	int ret;

	/* FIXME: This is a potential infinite loop.
	 *        NWG: 18/05/2003.
	 */
	do {
		/* With this we get the status, when return 0 it's all ok */
		ret = spca50x_reg_read(spca50x->dev, 0x06, 0x00, 1);
	} while(ret != 0);
}


static void spca50x_GetFirmware(struct usb_spca50x *spca50x)
{	__u8 FW[5] = {0,0,0,0,0};
	__u8 ProductInfo[64];
	
	spca5xxRegRead(spca50x->dev,0x20 ,0 ,0 ,FW ,5);
	PDEBUG(0, "FirmWare : %d %d %d %d %d ", FW[0],FW[1],FW[2],FW[3],FW[4] );
	spca5xxRegRead(spca50x->dev,0x23 ,0 ,0 ,ProductInfo ,64);
	spca5xxRegRead(spca50x->dev,0x23 ,0 ,1 ,ProductInfo ,64);
	return ;
}


static int spca504B_PollingDataReady(struct usb_device *dev)		            
{	
	__u8 DataReady = 0 ;
	int count = 0;
	while(1) {
		spca5xxRegRead(dev,0x21,0, 0, &DataReady,1);
		if ( (DataReady & 0x01) == 0) break;
		wait_ms(10);
		count++;
		if (count > 10) break;
		
	}
	return DataReady;
}


static void spca504B_WaitCmdStatus(struct usb_spca50x *spca50x)
{	
	__u8 DataReady = 0;
	int ReqDone;
	int count = 0;
	while (1) {
		spca5xxRegRead(spca50x->dev,0x21,0, 1, &DataReady,1);

		if ( DataReady ) {
			DataReady = 0;
			spca5xxRegWrite(spca50x->dev,0x21,0, 1, &DataReady, 1);		
			spca5xxRegRead(spca50x->dev,0x21,0, 1, &DataReady, 1);
			ReqDone = spca504B_PollingDataReady(spca50x->dev);
			break ;           
		}
		wait_ms (10);	
		count++;
		if (count > 50) break;
		
	} 
	return ;
}


static void spca504B_setQtable ( struct usb_spca50x *spca50x )
{
	__u8 Data = 3 ;
	int rc ;
	spca5xxRegWrite(spca50x->dev,0x26,0 ,0 ,&Data ,1 );
	spca5xxRegRead(spca50x->dev,0x26 ,0 ,0 , &Data ,1);
	rc = spca504B_PollingDataReady ( spca50x->dev );
	return ;
}

static void spca504B_SetSizeType(struct usb_spca50x *spca50x , __u16 extSize ,__u16 extType)
{
	__u8 Size ;
	__u8 Type ;
	int rc;
	Size = (__u8) extSize;
	Type = (__u8) extType;
	
	if ( spca50x->bridge == BRIDGE_SPCA533) {
		spca5xxRegWrite(spca50x->dev,0x31,0 ,0 ,NULL ,0 );
		spca504B_WaitCmdStatus(spca50x);
		rc = spca504B_PollingDataReady(spca50x->dev);
	
		spca50x_GetFirmware( spca50x );
		
		Type = 2;
		spca5xxRegWrite(spca50x->dev,0x24,0 ,8 ,&Type ,1 );
		spca5xxRegRead(spca50x->dev,0x24,0 ,8 ,&Type ,1 );
	
		spca5xxRegWrite(spca50x->dev,0x25,0 ,4 ,&Size ,1 );
		spca5xxRegRead(spca50x->dev,0x25,0 ,4 ,&Size ,1 );
		rc = spca504B_PollingDataReady(spca50x->dev );	
	
		/* Init the cam width height with some values get on init ?*/
		spca5xxRegWrite(spca50x->dev,0x31,0 ,4 ,NULL ,0 );
		spca504B_WaitCmdStatus( spca50x );
		
				rc = spca504B_PollingDataReady(spca50x->dev );	
	
	}
	
	
	if ( spca50x->bridge == BRIDGE_SPCA504B){
		spca5xxRegWrite(spca50x->dev,0x25,0 ,4 ,&Size ,1 );
		spca5xxRegRead(spca50x->dev,0x25,0 ,4 ,&Size ,1 );
		spca5xxRegWrite(spca50x->dev,0x27,0 ,0 ,&Type ,1 );
		spca5xxRegRead(spca50x->dev,0x27,0 ,0 ,&Type ,1 );
		
		rc = spca504B_PollingDataReady ( spca50x->dev );
	}
	
	return ;
}

static void spca504B_SetInitRegs(struct usb_spca50x *spca50x)
{	
	int rc ;	
	
	if (spca50x->bridge == BRIDGE_SPCA504B){
	/* Like snoops ? */
	// --------------------- perhaps not necessary -----------------------
	spca5xxRegWrite(spca50x->dev,0x1d ,0 ,0 ,NULL,0 );	
	spca5xxRegWrite(spca50x->dev,0,1 ,0x2306 ,NULL ,0 );
	spca5xxRegWrite(spca50x->dev,0,0 ,0x0d04 ,NULL ,0 );

	// --------------------- but sometimes lost init-----------------------

	spca5xxRegWrite(spca50x->dev,0,0 ,0x2000 ,NULL ,0 );
	spca5xxRegWrite(spca50x->dev,0,0x13 ,0x2301 ,NULL ,0 );
	spca5xxRegWrite(spca50x->dev,0,0 ,0x2306 ,NULL ,0 );
	
	}
	
	rc = spca504B_PollingDataReady ( spca50x->dev );
	spca50x_GetFirmware( spca50x );

	return ;
}


static void spca504B_SetPcCamStart (struct usb_spca50x *spca50x)
{
	int rc ;		
	spca5xxRegWrite(spca50x->dev,0x31,0 ,4 ,NULL ,0 );
	spca504B_WaitCmdStatus( spca50x );
	rc = spca504B_PollingDataReady(spca50x->dev );
	return ;
}

static void spca504B_stop (struct usb_spca50x *spca50x)
{
	int rc ;
	spca5xxRegWrite(spca50x->dev,0x31,0 ,0 ,NULL ,0 );
	spca504B_WaitCmdStatus(spca50x);
	rc = spca504B_PollingDataReady(spca50x->dev);
	return ;
}


static void spca504B_setContBrigHueRegisters (struct usb_spca50x *spca50x)
{	
	int rc ;
	spca5xxRegWrite(spca50x->dev,0 ,0 ,0x21a7 ,NULL ,0 );
	spca5xxRegWrite(spca50x->dev,0 ,0x20 ,0x21a8 ,NULL ,0 );
	spca5xxRegWrite(spca50x->dev,0 ,0 ,0x21ad ,NULL ,0 );
	spca5xxRegWrite(spca50x->dev,0 ,1 ,0x21ac ,NULL ,0 );
	spca5xxRegWrite(spca50x->dev,0 ,0x20 ,0x21ae ,NULL ,0 );
	spca5xxRegWrite(spca50x->dev,0 ,0 ,0x21a3 ,NULL ,0 );
	rc = spca504B_PollingDataReady( spca50x->dev );
	return ;
}

static void spca504B_init (struct usb_spca50x *spca50x)
{	
	spca504B_SetInitRegs( spca50x );	
	return;
}

static void spca504B_start (struct usb_spca50x *spca50x)
{	
	spca504B_setContBrigHueRegisters ( spca50x );
	if (spca50x->bridge == BRIDGE_SPCA504B){
		spca504B_setQtable ( spca50x );
		spca504B_SetPcCamStart ( spca50x );
	}
	
}
#endif /* SPCA504_INIT_H */

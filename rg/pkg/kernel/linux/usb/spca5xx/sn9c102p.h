/****************************************************************************
#	 	Sonix sn9c102p library                                      #
# 		Copyright (C) 2005 Michel Xhaard   mxhaard@magic.fr         #
#                                                                           #
# This program is free software; you can redistribute it and/or modify      #
# it under the terms of the GNU General Public License as published by      #
# the Free Software Foundation; either version 2 of the License, or         #
# (at your option) any later version.                                       #
#                                                                           #
# This program is distributed in the hope that it will be useful,           #
# but WITHOUT ANY WARRANTY; without even the implied warranty of            #
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the             #
# GNU General Public License for more details.                              #
#                                                                           #
# You should have received a copy of the GNU General Public License         #
# along with this program; if not, write to the Free Software               #
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA #
#                                                                           #
****************************************************************************/
static int sn9c102p_init(struct usb_spca50x *spca50x);
static void sn9c102p_start(struct usb_spca50x *spca50x);
static void sn9c102p_stop(struct usb_spca50x *spca50x);
static __u16 sn9c102p_setbrightness(struct usb_spca50x *spca50x);
static __u16 sn9c102p_getbrightness(struct usb_spca50x *spca50x);
static __u16 sn9c102p_setcontrast(struct usb_spca50x *spca50x);
static __u16 sn9c102p_getcontrast(struct usb_spca50x *spca50x);
//static void sn9c102p_setAutobright (struct usb_spca50x *spca50x);
//static void sn9c102p_shutdown(struct usb_spca50x *spca50x);
static int sn9c102p_probesensor(struct usb_spca50x *spca50x);

static __u8 sn9c102p[]= {
  0x00, 0x03, 0x64, 0x00, 0x1A, 0x20, 0x20, 0x20, 0xA1, 0x11, 0x02, 0x09, 0x00, 0x00, 0x00, 0x10, 0x03, 0x00,
//reg0  reg1  reg2  reg3  reg4  reg5  reg6  reg7  reg8  reg9  rega  regb  regc  regd  rege  regf  reg10 reg11
  0x00, 0x01, 0x03, 0x28, 0x1e, 0x41, 0x1a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
//reg12 reg13 reg14 reg15 reg16 reg17 reg18 reg19 reg1a reg1b reg1c reg1d reg1e reg1f reg20 reg21 reg22 reg23
};

static __u8 reg9a[] = {
	0x08, 0x40, 0x20, 0x10, 0x00, 0x04
};

static __u8 regsn20[] = { 
	0x00, 0x2D, 0x46, 0x5A, 0x6C, 0x7C, 0x8B, 0x99, 0xA6, 0xB2, 0xBF, 0xCA, 0xD5, 0xE0, 0xEB, 0xF5, 0xFF
};
static __u8 reg84[] = {
	0x14, 0x00, 0x27, 0x00, 0x07, 0x00, 0xE5, 0x0F, 0xE4, 0x0F, 0x38, 0x00, 0x3E, 0x00, 0xC3, 0x0F,
	0x00, 0x00, 0x00, 0x00, 0x00
};
#if 0
static __u8 qtable1[] = {
	0x0B, 0x07, 0x07, 0x0B, 0x07, 0x07, 0x0B, 0x0B, 0x0B, 0x0B, 0x0E, 0x0B, 0x0B, 0x0E, 0x12, 0x1D,
	0x12, 0x12, 0x0E, 0x0E, 0x12, 0x24, 0x19, 0x19, 0x15, 0x1D, 0x2B, 0x24, 0x2B, 0x2B, 0x27, 0x24,
	0x27, 0x27, 0x2F, 0x32, 0x40, 0x39, 0x2F, 0x32, 0x3D, 0x32, 0x27, 0x27, 0x39, 0x4F, 0x39, 0x3D,
	0x44, 0x48, 0x4B, 0x4B, 0x4B, 0x2B, 0x36, 0x52, 0x56, 0x4F, 0x48, 0x56, 0x40, 0x48, 0x4B, 0x48,
	0x0B, 0x0E, 0x0E, 0x12, 0x0E, 0x12, 0x20, 0x12, 0x12, 0x20, 0x48, 0x2F, 0x27, 0x2F, 0x48, 0x48,
	0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48,
	0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48,
	0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48 
};
static __u8 qtable2[] = {	
	0x09, 0x06, 0x06, 0x09, 0x06, 0x06, 0x09, 0x09, 0x09, 0x09, 0x0C, 0x09, 0x09, 0x0C, 0x0F, 0x18,
	0x0F, 0x0F, 0x0C, 0x0C, 0x0F, 0x1E, 0x15, 0x15, 0x12, 0x18, 0x24, 0x1E, 0x24, 0x24, 0x21, 0x1E,
	0x21, 0x21, 0x27, 0x2A, 0x36, 0x30, 0x27, 0x2A, 0x33, 0x2A, 0x21, 0x21, 0x30, 0x42, 0x30, 0x33,
	0x39, 0x3C, 0x3F, 0x3F, 0x3F, 0x24, 0x2D, 0x45, 0x48, 0x42, 0x3C, 0x48, 0x36, 0x3C, 0x3F, 0x3C,
	0x09, 0x0C, 0x0C, 0x0F, 0x0C, 0x0F, 0x1B, 0x0F, 0x0F, 0x1B, 0x3C, 0x27, 0x21, 0x27, 0x3C, 0x3C,
	0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C,
	0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C,
	0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C 
};
#endif
static __u8 qtable3[] = {	
	0x07, 0x05, 0x05, 0x07, 0x05, 0x05, 0x07, 0x07, 0x07, 0x07, 0x0A, 0x07, 0x07, 0x0A, 0x0C, 0x14,
	0x0C, 0x0C, 0x0A, 0x0A, 0x0C, 0x19, 0x11, 0x11, 0x0F, 0x14, 0x1E, 0x19, 0x1E, 0x1E, 0x1B, 0x19,
	0x1B, 0x1B, 0x20, 0x23, 0x2D, 0x28, 0x20, 0x23, 0x2A, 0x23, 0x1B, 0x1B, 0x28, 0x37, 0x28, 0x2A,
	0x2F, 0x32, 0x34, 0x34, 0x34, 0x1E, 0x25, 0x39, 0x3C, 0x37, 0x32, 0x3C, 0x2D, 0x32, 0x34, 0x32,
	0x07, 0x0A, 0x0A, 0x0C, 0x0A, 0x0C, 0x16, 0x0C, 0x0C, 0x16, 0x32, 0x20, 0x1B, 0x20, 0x32, 0x32,
	0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32,
	0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32,
	0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32
};
#if 0
static __u8 qtable4[] = {	
	0x06, 0x04, 0x04, 0x06, 0x04, 0x04, 0x06, 0x06, 0x06, 0x06, 0x08, 0x06, 0x06, 0x08, 0x0A, 0x11,
	0x0A, 0x0A, 0x08, 0x08, 0x0A, 0x15, 0x0F, 0x0F, 0x0C, 0x11, 0x19, 0x15, 0x19, 0x19, 0x17, 0x15,
	0x17, 0x17, 0x1B, 0x1D, 0x25, 0x21, 0x1B, 0x1D, 0x23, 0x1D, 0x17, 0x17, 0x21, 0x2E, 0x21, 0x23,
	0x27, 0x29, 0x2C, 0x2C, 0x2C, 0x19, 0x1F, 0x30, 0x32, 0x2E, 0x29, 0x32, 0x25, 0x29, 0x2C, 0x29,
	0x06, 0x08, 0x08, 0x0A, 0x08, 0x0A, 0x13, 0x0A, 0x0A, 0x13, 0x29, 0x1B, 0x17, 0x1B, 0x29, 0x29,
	0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29,
	0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29,
	0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29 
};
static __u8 qtable5[] = {	
	0x05, 0x03, 0x03, 0x05, 0x03, 0x03, 0x05, 0x05, 0x05, 0x05, 0x07, 0x05, 0x05, 0x07, 0x09, 0x0E,
	0x09, 0x09, 0x07, 0x07, 0x09, 0x11, 0x0C, 0x0C, 0x0A, 0x0E, 0x15, 0x11, 0x15, 0x15, 0x13, 0x11,
	0x13, 0x13, 0x16, 0x18, 0x1F, 0x1C, 0x16, 0x18, 0x1D, 0x18, 0x13, 0x13, 0x1C, 0x26, 0x1C, 0x1D,
	0x21, 0x23, 0x24, 0x24, 0x24, 0x15, 0x1A, 0x28, 0x29, 0x26, 0x23, 0x29, 0x1F, 0x23, 0x24, 0x23,
	0x05, 0x07, 0x07, 0x09, 0x07, 0x09, 0x10, 0x09, 0x09, 0x10, 0x23, 0x16, 0x13, 0x16, 0x23, 0x23,
	0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23,
	0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23,
	0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23 
};
static __u8 qtable6[] = {	
	 0x04, 0x03, 0x03, 0x04, 0x03, 0x03, 0x04, 0x04, 0x04, 0x04, 0x06, 0x04, 0x04, 0x06, 0x07, 0x0C,
	 0x07, 0x07, 0x06, 0x06, 0x07, 0x0E, 0x0A, 0x0A, 0x09, 0x0C, 0x11, 0x0E, 0x11, 0x11, 0x10, 0x0E,
	 0x10, 0x10, 0x13, 0x14, 0x1A, 0x17, 0x13, 0x14, 0x18, 0x14, 0x10, 0x10, 0x17, 0x20, 0x17, 0x18,
	 0x1B, 0x1D, 0x1E, 0x1E, 0x1E, 0x11, 0x16, 0x21, 0x23, 0x20, 0x1D, 0x23, 0x1A, 0x1D, 0x1E, 0x1D,
	 0x04, 0x06, 0x06, 0x07, 0x06, 0x07, 0x0D, 0x07, 0x07, 0x0D, 0x1D, 0x13, 0x10, 0x13, 0x1D, 0x1D,
	 0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D,
	 0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D,
	 0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D 
};
static __u8 qtable7[] = {	
	 0x04, 0x02, 0x02, 0x04, 0x02, 0x02, 0x04, 0x04, 0x04, 0x04, 0x05, 0x04, 0x04, 0x05, 0x06, 0x0A,
	 0x06, 0x06, 0x05, 0x05, 0x06, 0x0C, 0x08, 0x08, 0x07, 0x0A, 0x0E, 0x0C, 0x0E, 0x0E, 0x0D, 0x0C,
	 0x0D, 0x0D, 0x10, 0x11, 0x16, 0x13, 0x10, 0x11, 0x14, 0x11, 0x0D, 0x0D, 0x13, 0x1A, 0x13, 0x14,
	 0x17, 0x18, 0x19, 0x19, 0x19, 0x0E, 0x12, 0x1C, 0x1D, 0x1A, 0x18, 0x1D, 0x16, 0x18, 0x19, 0x18,
	 0x04, 0x05, 0x05, 0x06, 0x05, 0x06, 0x0B, 0x06, 0x06, 0x0B, 0x18, 0x10, 0x0D, 0x10, 0x18, 0x18,
	 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
	 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
	 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18 
};
static __u8 qtable8[] = {	
	 0x03, 0x02, 0x02, 0x03, 0x02, 0x02, 0x03, 0x03, 0x03, 0x03, 0x04, 0x03, 0x03, 0x04, 0x05, 0x08,
	 0x05, 0x05, 0x04, 0x04, 0x05, 0x0A, 0x07, 0x07, 0x06, 0x08, 0x0C, 0x0A, 0x0C, 0x0C, 0x0B, 0x0A,
	 0x0B, 0x0B, 0x0D, 0x0E, 0x12, 0x10, 0x0D, 0x0E, 0x11, 0x0E, 0x0B, 0x0B, 0x10, 0x16, 0x10, 0x11,
	 0x13, 0x14, 0x15, 0x15, 0x15, 0x0C, 0x0F, 0x17, 0x18, 0x16, 0x14, 0x18, 0x12, 0x14, 0x15, 0x14,
	 0x03, 0x04, 0x04, 0x05, 0x04, 0x05, 0x09, 0x05, 0x05, 0x09, 0x14, 0x0D, 0x0B, 0x0D, 0x14, 0x14,
	 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14,
	 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14,
	 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14 
};
#endif
 static __u8 hv7131r_sensor_init[][8]={
	{ 0xC1, 0x11, 0x01, 0x08, 0x01, 0x00, 0x00, 0x10 },
	{ 0xB1, 0x11, 0x34, 0x17, 0x7F, 0x00, 0x00, 0x10 },
	{ 0xD1, 0x11, 0x40, 0xFF, 0x7F, 0x7F, 0x7F, 0x10 },
	{ 0x91, 0x11, 0x44, 0x00, 0x00, 0x00, 0x00, 0x10 },
	{ 0xD1, 0x11, 0x10, 0x00, 0x00, 0x00, 0x00, 0x10 },
	{ 0xD1, 0x11, 0x14, 0x01, 0xE2, 0x02, 0x82, 0x10 },
	{ 0x91, 0x11, 0x18, 0x00, 0x00, 0x00, 0x00, 0x10 },
	{ 0, 0, 0, 0, 0, 0, 0, 0 }
};
//initdone
 static __u8 hv7131r_sensor_config[][8]={	
	{ 0xA1, 0x11, 0x01, 0x08, 0x00, 0x00, 0x00, 0x10 },
	{ 0xA1, 0x11, 0x01, 0x08, 0x00, 0x00, 0x00, 0x10 },
	{ 0xC1, 0x11, 0x25, 0x00, 0x61, 0xA8, 0x00, 0x10 },
	{ 0xA1, 0x11, 0x30, 0x22, 0x00, 0x00, 0x00, 0x10 },
	{ 0xC1, 0x11, 0x31, 0x20, 0x2E, 0x20, 0x00, 0x10 },
	{ 0xC1, 0x11, 0x25, 0x00, 0xC3, 0x50, 0x00, 0x10 },
	{ 0xA1, 0x11, 0x30, 0x14, 0x00, 0x00, 0x00, 0x10 },
	{ 0xC1, 0x11, 0x31, 0x10, 0x1A, 0x10, 0x00, 0x10 },	
//
	{ 0xA1, 0x11, 0x01, 0x08, 0x00, 0x00, 0x00, 0x10 },
	{ 0xA1, 0x11, 0x20, 0x00, 0x00, 0x00, 0x00, 0x10 },
	{ 0xA1, 0x11, 0x21, 0xD0, 0x00, 0x00, 0x00, 0x10 },
	{ 0xA1, 0x11, 0x22, 0x00, 0x00, 0x00, 0x00, 0x10 },
	{ 0xA1, 0x11, 0x23, 0x09, 0x00, 0x00, 0x00, 0x10 },
	{ 0, 0, 0, 0, 0, 0, 0, 0 }
};
//setqtable
static __u8 hv7131r_sensor_start[][8]={	
	{ 0xA1, 0x11, 0x01, 0x08, 0x00, 0x00, 0x00, 0x10 },
	{ 0xA1, 0x11, 0x20, 0x00, 0x00, 0x00, 0x00, 0x10 },
	{ 0xA1, 0x11, 0x21, 0xD0, 0x00, 0x00, 0x00, 0x10 },
	{ 0xA1, 0x11, 0x22, 0x00, 0x00, 0x00, 0x00, 0x10 },
	{ 0xA1, 0x11, 0x23, 0x10, 0x00, 0x00, 0x00, 0x10 },
	{ 0, 0, 0, 0, 0, 0, 0, 0 }
};	
static int sn9c102p_i2cwrite (struct usb_device *dev,__u8 *buffer,__u16 length)
{
	__u8 mode[] = {0x81,0x11,0,0,0,0,0,0x10};
	/* is i2c ready */
	if (length > 5 || !buffer) return -1;
	mode[0] = mode[0] |length << 4 ;
	memcpy(&mode[2],buffer,length);
	sonixRegWrite(dev,0x08,0x08,0x0000,mode,8);	
	return 0;
}
static void sn9c102p_i2cwritebuf (struct usb_device *dev,__u8 *buffer )
{
	sonixRegWrite(dev,0x08,0x08,0x0000,buffer,8);	
	
}
 static int sn9c102p_i2cread (struct usb_device *dev,__u8 reg,__u8 *buffer,__u16 length)
{
	__u8 mode[] = {0x91,0x11,0,0,0,0,0,0x10};
	__u8 result[] = {0,0,0,0,0};
	if (length > 5 || !buffer) return -1;
	mode[2] = reg;
	sonixRegWrite(dev,0x08,0x08,0x0000,mode,8);
	mode[2] = 0;
	mode[0] = 0x81 | length << 4 | 0x02;
	sonixRegWrite(dev,0x08,0x08,0x0000,mode,8);
	sonixRegRead(dev,0x00,0x0a,0x0000,result,5);
	memcpy(buffer,result,length);
	return 0;
}

static int sn9c102p_init(struct usb_spca50x *spca50x)
{	
	struct usb_device *dev = spca50x->dev;
	int err = 0;
	__u8 regF1 = 0x01;
	__u8 regGpio = 0x74;
	__u8 data = 0x00;
	sonixRegWrite(dev,0x08,0xf1,0x0000,&regF1,1);
	//{ 0x41, 0x08, 0x00F1, 0x0000, 0x0001, 0x0001, "\x01" },
	sonixRegRead(dev,0x00,0x00,0x0000,&regF1,1);
	//{ 0xC1, 0x00, 0x0000, 0x0000, 0x0001, 0x0001, "\x00" },
	sonixRegWrite(dev,0x08,0xf1,0x0000,&regF1,1);
	//{ 0x41, 0x08, 0x00F1, 0x0000, 0x0001, 0x0001, "\x00" },
	sonixRegRead(dev,0x00,0x00,0x0000,&regF1,1);
	//{ 0xC1, 0x00, 0x0000, 0x0000, 0x0001, 0x0001, "\x11" },
	if (regF1 != 0x11) return -ENODEV;
	sonixRegWrite(dev,0x08,0x02,0x0000,&regGpio,1);
	//{ 0x41, 0x08, 0x0002, 0x0000, 0x0001, 0x0001, "\x74" },
	regF1 = 0x01;
	sonixRegWrite(dev,0x08,0xf1,0x0000,&regF1,1);
	//{ 0x41, 0x08, 0x00F1, 0x0000, 0x0001, 0x0001, "\x01" },
	//-------------------------------------------------------
	regF1 = 0x00;
	sonixRegWrite(dev,0x08,0xf1,0x0000,&regF1,1);
	//{ 0x41, 0x08, 0x00F1, 0x0000, 0x0001, 0x0001, "\x00" },
	sonixRegWrite(dev,0x08,0x01,0x0000,&sn9c102p[1],1);
	//{ 0x41, 0x08, 0x0001, 0x0000, 0x0001, 0x0001, "\x03" },
	// verify the sonix chips id and registers 0x01 access
	//{ 0xC1, 0x00, 0x0000, 0x0000, 0x0001, 0x0001, "\x11" },
	//{ 0xC1, 0x00, 0x0001, 0x0000, 0x0001, 0x0001, "\x03" },
	// configure gpio 
	sonixRegWrite(dev,0x08,0x01,0x0000,&sn9c102p[1],2);
	//{ 0x41, 0x08, 0x0001, 0x0000, 0x0002, 0x0002, "\x03\x64" },
	sonixRegWrite(dev,0x08,0x08,0x0000,&sn9c102p[8],2);
	//{ 0x41, 0x08, 0x0008, 0x0000, 0x0002, 0x0002, "\xA1\x11" },
	sonixRegWrite(dev,0x08,0x017,0x0000,&sn9c102p[0x17],3);
	//{ 0x41, 0x08, 0x0017, 0x0000, 0x0003, 0x0003, "\x41\x1A\x00" },
	sonixRegWrite(dev,0x08,0x9a,0x0000,reg9a,6);
	//{ 0x41, 0x08, 0x009A, 0x0000, 0x0006, 0x0006, "\x08\x40\x20\x10\x00\x04" },
	data= 0x60;
	sonixRegWrite(dev,0x08,0xD4,0x0000,&data,1);
	//{ 0x41, 0x08, 0x00D4, 0x0000, 0x0001, 0x0001, "\x60" },
	sonixRegWrite(dev,0x08,0x03,0x0000,&sn9c102p[3],0x0f);
	//{ 0x41, 0x08, 0x0003, 0x0000, 0x000F, 0x000F, "\x00\x1A\x20\x20\x20\xA1\x11\x02\x09\x00\x00\x00\x10\x03\x00" },
	data= 0x43;
	sonixRegWrite(dev,0x08,0x01,0x0000,&data,1);
	//{ 0x41, 0x08, 0x0001, 0x0000, 0x0001, 0x0001, "\x43" },
	data= 0x61;
	sonixRegWrite(dev,0x08,0x17,0x0000,&data,1);
	//{ 0x41, 0x08, 0x0017, 0x0000, 0x0001, 0x0001, "\x61" },
	data= 0x42;
	sonixRegWrite(dev,0x08,0x01,0x0000,&data,1);
	//{ 0x41, 0x08, 0x0001, 0x0000, 0x0001, 0x0001, "\x42" },
	// probe sensor
	if((err = sn9c102p_probesensor(spca50x)) < 0)
		return -ENODEV;
		
return 0;
}
static void sn9c102p_stop(struct usb_spca50x *spca50x)
{ 
	struct usb_device *dev = spca50x->dev;
	__u8 stopsensor[] = { 0xA1, 0x11, 0x02, 0x09, 0x00, 0x00, 0x00, 0x10 };
	__u8 regF1 = 0x01;
	__u8 data = 0x0b;
	sn9c102p_i2cwritebuf (dev,stopsensor);
	sonixRegWrite(dev,0x08,0x01,0x0000,&sn9c102p[1],1);
	sonixRegWrite(dev,0x08,0x17,0x0000,&sn9c102p[0x17],1);
	sonixRegWrite(dev,0x08,0x01,0x0000,&sn9c102p[1],1);
	sonixRegWrite(dev,0x08,0x01,0x0000,&data,1);
	sonixRegWrite(dev,0x08,0xf1,0x0000,&regF1,1);
}

static int sn9c102p_probesensor(struct usb_spca50x *spca50x)
{       struct usb_device *dev = spca50x->dev;
	int err = 0;
	__u8 reg02 = 0x66;
	/* reg val1 val2 val3 val4 */
	__u8 datasend[] = {0,0,0,0,0};
	__u8 datarecd[] = {0,0,0,0,0};
	datasend[0] = 2; //sensor wakeup
	err = sn9c102p_i2cwrite (dev, datasend ,2);
	sonixRegWrite(dev,0x08,0x02,0x0000,&reg02,1); //Gpio on
	err += sn9c102p_i2cread (dev,0, datarecd ,5); //read sensor id
	if (err) goto errors;
	if(datarecd[0] == 0x02 && datarecd[1] == 0x09 && datarecd[2] == 0x01 
		&& datarecd[3] == 0x00 && datarecd[4] == 0x00){
		PDEBUG(0,"Find Sensor sn9c102P HV7131R");
		spca50x->sensor = SENSOR_HV7131R;
		return SENSOR_HV7131R;
		}
	PDEBUG(0,"Sensor sn9c102P Not found Contact mxhaard@free.fr ");	
	return -ENODEV;	
errors:	PDEBUG(0,"Sensor sn9c102P too many errors Contact mxhaard@free.fr ");
return -ENODEV;	
}

static void hv7131R_InitSensor(struct usb_spca50x *spca50x)
{
	int i = 0;
	struct usb_device *dev = spca50x->dev;
	while (hv7131r_sensor_init[i][0]){
	sn9c102p_i2cwritebuf (dev,hv7131r_sensor_init[i]);
	i++;
	}	
}
static void hv7131R_ConfigSensor(struct usb_spca50x *spca50x)
{
	int i = 0;
	struct usb_device *dev = spca50x->dev;
	while (hv7131r_sensor_config[i][0]){
	sn9c102p_i2cwritebuf (dev,hv7131r_sensor_config[i]);
	i++;
	}	
}
static void hv7131R_StartSensor(struct usb_spca50x *spca50x)
{
	int i = 0;
	struct usb_device *dev = spca50x->dev;
	__u8 CtrlA320[] = { 0xA1, 0x11, 0x01, 0x08, 0x00, 0x00, 0x00, 0x10 }; //Mclk
	//__u8 CtrlA640[] = { 0xA1, 0x11, 0x01, 0x18, 0x00, 0x00, 0x00, 0x10 };//Mclk/2
	__u8 CtrlA640[] = { 0xA1, 0x11, 0x01, 0x28, 0x00, 0x00, 0x00, 0x10 }; //Mckl/4
	while (hv7131r_sensor_start[i][0]){
	sn9c102p_i2cwritebuf (dev,hv7131r_sensor_start[i]);
	i++;
	}
	if(spca50x->mode)
	 sn9c102p_i2cwritebuf (dev,CtrlA320);
	else
	 sn9c102p_i2cwritebuf (dev,CtrlA640);	
}
static void sn9c102p_start(struct usb_spca50x *spca50x)
{	
	struct usb_device *dev = spca50x->dev;
	int i;
	__u8 DC29[]={0x6a, 0x50, 0x00, 0x00, 0x50, 0x3c};
	__u8 C0[]={0x2d, 0x2d, 0x3a, 0x05, 0x04, 0x3f};
	__u8 CA[]={0x28, 0xd8, 0x14, 0xec };
	__u8 CE[]={0x28, 0xec, 0x1e, 0xec };
	__u8 PreAInit[] = { 0xa1, 0x11, 0x30, 0x1a, 0x00, 0x00, 0x00, 0x1d };
	__u8 RInit[] = { 0xa1, 0x11, 0x31, 0x26, 0x00, 0x00, 0x00, 0x18 };
	__u8 data = 0;
	__u8 regF1 = 0x00;
	int err = 0;
	
	
	sonixRegWrite(dev,0x08,0xf1,0x0000,&regF1,1);
	//{ 0x41, 0x08, 0x00F1, 0x0000, 0x0001, 0x0001, "\x00" },
	sonixRegWrite(dev,0x08,0x01,0x0000,&sn9c102p[1],1);
	//{ 0x41, 0x08, 0x0001, 0x0000, 0x0001, 0x0001, "\x03" },
	// verify the sonix chips id and registers 0x01 access
	//{ 0xC1, 0x00, 0x0000, 0x0000, 0x0001, 0x0001, "\x11" },
	//{ 0xC1, 0x00, 0x0001, 0x0000, 0x0001, 0x0001, "\x03" },
	// configure gpio 
	sonixRegWrite(dev,0x08,0x01,0x0000,&sn9c102p[1],2);
	//{ 0x41, 0x08, 0x0001, 0x0000, 0x0002, 0x0002, "\x03\x64" },
	sonixRegWrite(dev,0x08,0x08,0x0000,&sn9c102p[8],2);
	//{ 0x41, 0x08, 0x0008, 0x0000, 0x0002, 0x0002, "\xA1\x11" },
	sonixRegWrite(dev,0x08,0x17,0x0000,&sn9c102p[0x17],3);
	//{ 0x41, 0x08, 0x0017, 0x0000, 0x0003, 0x0003, "\x41\x1A\x00" },
	sonixRegWrite(dev,0x08,0x9a,0x0000,reg9a,6);
	//{ 0x41, 0x08, 0x009A, 0x0000, 0x0006, 0x0006, "\x08\x40\x20\x10\x00\x04" },
	data= 0x60;
	sonixRegWrite(dev,0x08,0xD4,0x0000,&data,1);
	//{ 0x41, 0x08, 0x00D4, 0x0000, 0x0001, 0x0001, "\x60" },
	sonixRegWrite(dev,0x08,0x03,0x0000,&sn9c102p[3],0x0f);
	//{ 0x41, 0x08, 0x0003, 0x0000, 0x000F, 0x000F, "\x00\x1A\x20\x20\x20\xA1\x11\x02\x09\x00\x00\x00\x10\x03\x00" },
	data= 0x43;
	sonixRegWrite(dev,0x08,0x01,0x0000,&data,1);
	//{ 0x41, 0x08, 0x0001, 0x0000, 0x0001, 0x0001, "\x43" },
	data= 0x61;
	sonixRegWrite(dev,0x08,0x17,0x0000,&data,1);
	//{ 0x41, 0x08, 0x0017, 0x0000, 0x0001, 0x0001, "\x61" },
	data= 0x42;
	sonixRegWrite(dev,0x08,0x01,0x0000,&data,1);
	if((err = sn9c102p_probesensor(spca50x)) < 0)
		return ;
 	hv7131R_InitSensor(spca50x);	
	sonixRegWrite(dev,0x08,0x15,0x0000,&sn9c102p[0x15],1);
	sonixRegWrite(dev,0x08,0x16,0x0000,&sn9c102p[0x16],1);
	sonixRegWrite(dev,0x08,0x12,0x0000,&sn9c102p[0x12],1);
	sonixRegWrite(dev,0x08,0x13,0x0000,&sn9c102p[0x13],1);
	sonixRegWrite(dev,0x08,0x18,0x0000,&sn9c102p[0x18],1);
	sonixRegWrite(dev,0x08,0xd2,0x0000,&DC29[0],1);
	sonixRegWrite(dev,0x08,0xd3,0x0000,&DC29[1],1);
	sonixRegWrite(dev,0x08,0xc6,0x0000,&DC29[2],1);
	sonixRegWrite(dev,0x08,0xc7,0x0000,&DC29[3],1);
	sonixRegWrite(dev,0x08,0xc8,0x0000,&DC29[4],1);
	sonixRegWrite(dev,0x08,0xc9,0x0000,&DC29[5],1);
	sonixRegWrite(dev,0x08,0x18,0x0000,&sn9c102p[0x18],1);
	data = 0x60;
	sonixRegWrite(dev,0x08,0x17,0x0000,&data,1);
	sonixRegWrite(dev,0x08,0x05,0x0000,&sn9c102p[5],1);
	sonixRegWrite(dev,0x08,0x07,0x0000,&sn9c102p[7],1);
	sonixRegWrite(dev,0x08,0x06,0x0000,&sn9c102p[6],1);
	sonixRegWrite(dev,0x08,0x14,0x0000,&sn9c102p[0x14],1);
	sonixRegWrite(dev,0x08,0x20,0x0000,regsn20,0x11);
	for (i=0; i<8;i++)
		sonixRegWrite(dev,0x08,0x84,0x0000,reg84,0x15);
	data = 0x08;
	sonixRegWrite(dev,0x08,0x9a,0x0000,&data,1);
	data = 0x59;
	sonixRegWrite(dev,0x08,0x99,0x0000,&data,1);
	sonixRegWrite(dev,0x08,0x05,0x0000,&sn9c102p[5],1);
	sonixRegWrite(dev,0x08,0x07,0x0000,&sn9c102p[7],1);
	sonixRegWrite(dev,0x08,0x06,0x0000,&sn9c102p[6],1);
	hv7131R_ConfigSensor(spca50x);
	sonixRegWrite(dev,0x08,0xc0,0x0000,C0,6);
	sonixRegWrite(dev,0x08,0xca,0x0000,CA,4);
	sonixRegWrite(dev,0x08,0xce,0x0000,CE,4);
	data = 0x02;
	sonixRegWrite(dev,0x08,0x01,0x0000,&data,1); // sensor on video on
	data = 0x61;
	sonixRegWrite(dev,0x08,0x17,0x0000,&data,1);
	// here change size mode 0 -> VGA; 1 -> CIF
	data = 0x4A | (spca50x->mode << 4 );
	sonixRegWrite(dev,0x08,0x18,0x0000,&data,1);
	sonixRegWrite(dev,0x08,0x100,0x0000,qtable3,0x40);
	sonixRegWrite(dev,0x08,0x140,0x0000,qtable3+0x40,0x40);
	data = 0x0A |(spca50x->mode << 4 );
	sonixRegWrite(dev,0x08,0x18,0x0000,&data,1);
	data = 0x02;
	sonixRegWrite(dev,0x08,0x01,0x0000,&data,1);
	data = 0x61;
	sonixRegWrite(dev,0x08,0x17,0x0000,&data,1);
	hv7131R_StartSensor(spca50x);
	if (spca50x->mode)
		data = 0x06; //320 clk 12Mhz
	else
		data = 0x46; //640 clk 24Mz
		// enable video on
	sonixRegWrite(dev,0x08,0x01,0x0000,&data,1);
	
	 err = sn9c102p_setbrightness(spca50x);
	 sn9c102p_i2cwritebuf (dev,PreAInit);
	 sn9c102p_i2cwritebuf (dev,RInit);
}

static unsigned int sn9c102p_getexposure(struct usb_spca50x *spca50x)
{	__u8 expo[] = {0,0,0,0,0};
	int err = 0;
	err += sn9c102p_i2cread (spca50x->dev,0x25, expo ,5); //read sensor exposure
	return (unsigned int) (expo[0] << 16 | expo[1] << 8 | expo[2]);
}

static unsigned int sn9c102p_setexposure(struct usb_spca50x *spca50x,unsigned int expo)
{	
	__u8 Expodoit[] = { 0xc1, 0x11, 0x25, 0x07, 0x27, 0xc0, 0x00, 0x16 };
	unsigned int expotimes = expo;
	unsigned int expotimesret = 0;
	
	Expodoit[3] = (expotimes >> 16) & 0xff;
	Expodoit[4] = (expotimes >> 8) & 0xff;
	Expodoit[5] = (expotimes & 0xff) ;
	sn9c102p_i2cwritebuf (spca50x->dev,Expodoit);
	wait_ms(10);
	expotimesret = sn9c102p_getexposure(spca50x);
	PDEBUG(5,"Exposure set %d ret %d ", expotimes,expotimesret);
	return 	expotimesret;
}
	
static __u16 sn9c102p_setbrightness(struct usb_spca50x *spca50x)
{	
	unsigned int expo,expotimesret ;
	__u8 k2;
	expo = spca50x->brightness << 4;
	if (expo > 0x002dc6c0) expo = 0x002dc6c0;
	if (expo < 0x02a0) expo = 0x02a0;
	expotimesret = sn9c102p_setexposure(spca50x,expo);
	if (expo != expotimesret)
		PDEBUG(0,"Error setting exposure !");
	
	k2 = spca50x->brightness >> 10;
	sonixRegWrite(spca50x->dev,0x08,0x96,0x0000,&k2,1);
return 0;
}

static __u16 sn9c102p_getbrightness(struct usb_spca50x *spca50x)
{	
	/* hardcoded registers seem not readable */
	spca50x->brightness = 0x7fff;	
return 0;
}

static __u16 sn9c102p_setcontrast(struct usb_spca50x *spca50x)
{
	__u8 k2;
	__u8 contrast[] = {0x14,0x00,0x28,0x00,0x07,0x00};
	k2 = spca50x->contrast >> 8;
	if (k2 > 0x7f) k2 = 0x7f;
	contrast[2] = k2;
	contrast[0] = (k2+1) >> 1;
	contrast[4] = (k2+1) / 5 ;
	sonixRegWrite(spca50x->dev,0x08,0x84,0x0000,contrast,6);
	
return 0;
}
static __u16 sn9c102p_getcontrast(struct usb_spca50x *spca50x)
{	
	/* hardcoded registers seem not readable */
	spca50x->contrast = 0x28 << 8;
return 0;
}

#if 0
static void sn9c102p_setAutobright (struct usb_spca50x *spca50x)
{ // GRR avg_lum from the header seem wrong set exposure on brightness instead
 // FIXME where is the avg lume value ??	
	unsigned int expotimes=0;
	unsigned int expotimesret = 0;
	
	__u8 luma_mean = 110;
	__u8 luma_delta = 20;
	__u8 spring = 4; // 4 choice so the gain registers follow with a little retard
	int delta;
	spin_lock_irq(&spca50x->v4l_lock);
	delta = spca50x->avg_lum ;
	spin_unlock_irq(&spca50x->v4l_lock);
	//PDEBUG(0,"Error setting exposure delta %d",delta);
	
	if((delta < (luma_mean - luma_delta)) ||
		(delta > (luma_mean + luma_delta))){
	expotimes = sn9c102p_getexposure(spca50x);
	expotimes += ((luma_mean - delta) >> spring); 
	expotimesret = sn9c102p_setexposure(spca50x,expotimes);
	if (expotimes != expotimesret)
		PDEBUG(0,"Error setting exposure !");
	}
	
}

static void sn9c102p_shutdown(struct usb_spca50x *spca50x)
{

}

#endif
